# 需求分析

## 数据模型

教学机构人员在课程审核通过后即可发布课程，课程发布后会公开展示在网站上供学生查看、选课和学习。

在网站上展示课程信息需要解决课程信息显示的性能问题，如果速度慢(排除网速)会影响用户的体验性。

> 如何去快速搜索课程？

打开课程详情页面仍然去查询数据库可行吗？

为了提高网站的速度需要将课程信息进行缓存，并且要将课程信息加入索引库方便搜索，下图显示了课程发布后课程信息的流转情况：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-110.png)

1. 向内容管理数据库的课程发布表存储课程发布信息，更新课程基本信息表中发布状态为已发布
2. 向Redis存储课程缓存信息 
3. 向Elasticsearch存储课程索引信息
4. 请求分布文件系统存储课程静态化页面(即html页面)，实现快速浏览课程详情页面    

课程发布表的数据来源于课程预发布表，它们的结构基本一样，只是课程发布表中的状态是课程发布状态  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-111.png)

* redis中的课程缓存信息是将课程发布表中的数据转为json进行存储。

* elasticsearch中的课程索引信息是根据搜索需要将课程名称、课程介绍等信息进行索引存储。

* MinIO中存储了课程的静态化页面文件（网页），查看课程详情是通过文件系统去浏览课程详情页面

# 分布式事务技术方案

## 分布式事务

一次课程发布操作需要向数据库、redis、elasticsearch、MinIO写四份数据，这里**存在分布式事务问题。**

> 本地事务 

平常我们在程序中**通过spring去控制事务是利用数据库本身的事务特性来实现**的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，此数据库只属于该应用，所以**基于本应用自己的关系型数据库的事务又被称为本地事务**。 

本地事务具有ACID四大特性，数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚。 

> 分布式事务

现在的需求是课程发布操作后将数据写入数据库、redis、elasticsearch、MinIO四个地方，这四个地方已经不限制在一个数据库内，是由四个分散的服务去提供，与这四个服务去通信需要网络通信，而网络存在不可到达性，这种分布式系统环境下，**通过与不同的服务进行网络通信去完成事务称之为分布式事务。**

在分布式系统中分布式事务的场景很多：

例如用户注册送积分，银行转账，创建订单减库存，这些都是分布式事务。

拿转账举例：

我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：

```java
begin transaction； 
//1.本地数据库操作：张三减少金额 
//2.本地数据库操作：李四增加金额 
commit transation; 
```

但是在分布式环境下，会变成下边这样：

```java
begin transaction； 
//1.本地数据库操作：张三减少金额 
//2.远程调用：让李四增加金额 

commit transation;
```

可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。 

因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应 

> 分布式事务业务场景

微服务架构：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-112.png)

单服务多数据库  :

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-113.png)

多服务单数据库：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-114.png)

## CAP理论

CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-115.png)

客户端经过网关访问用户服务的两个结点，一致性是指用户不管访问哪一个结点拿到的数据都是最新的，比如查询小明的信息，不能出现在数据没有改变的情况下两次查询结果不一样  

**可用性**：指任何时候查询用户信息都可以查询到结果，但不保证查询到最新的数据。

**分区容忍性**：也叫分区容错性，当系统采用分布式架构时由于网络通信异常导致请求中断、消息丢失，但系统依然对外提供服务。

CAP理论要强调的是在分布式系统中这三点不可能全部满足，由于是分布式系统就要满足分区容忍性，因为服务之间难免出现网络异常，不能因为局部网络异常导致整个系统不可用。

满足P那么C和A不能同时满足：

比如我们添加一个用户小明的信息，该信息先添加到结点1中，再同步到结点2中，  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-116.png)

如果要满足C一致性，必须等待小明的信息同步完成系统才可用（否则会出现请求到结点2时查询不到数据，违反了一致性），在信息同步过程中系统是不可用的，所以满足C的同时无法满足A。

如果要满足A可用性，要时刻保证系统可用就不用等待信息同步完成，此时系统的一致性无法满足。

 **所以在分布式系统中进行分布式事务控制，要么保证CP、要么保证AP**  

## 分布式事务控制方案

分布式事务控制要在C和A中作出取舍，保证一致性就不要保证可用性，保证可用性就不要保证一致，首先你确认是要CP还是AP，具体要根据应用场景进行判断。

> CP的场景：满足C舍弃A，强调一致性。

**跨行转账**：一次转账请求要等待双方银行系统都完成整个事务才算完成，只要其中一个失败另一方执行回滚操作。

**开户操作**：在业务系统开户同时要在运营商开户，任何一方开户失败该用户都不可使用，所以要满足CP。

> AP的场景：满足A舍弃C，强调可用性。

**订单退款**，今日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。

**注册送积分**，注册成功积分在24分到账。

**支付短信通信**，支付成功发短信，短信发送可以有延迟，甚至没有发送成功。

> 在实际应用中符合AP的场景较多，其实虽然AP舍弃C一致性，实际上最终数据还是达到了一致，也就满足了最终一致性，所以业界定义了BASE理论。

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。

**基本可用**：当系统无法满足全部可用时保证核心服务可用即可，比如一个外卖系统，每到中午12点左右系统并发量很高，此时要保证下单流程涉及的服务可用，其它服务暂时不可用。

**软状态**：是指可以存在中间状态，比如：打印自己的社保统计情况，该操作不会立即出现结果，而是提示你打印中，请在XXX时间后查收。虽然出现了中间状态，但最终状态是正确的。

**最终一致性**：退款操作后没有及时到账，经过一定的时间后账户到账，舍弃强一致性，满足最终一致性。

> 分布式事务控制常用的技术方案

* **实现CP就是要实现强一致性:**

  * 使用Seata框架基于AT模式实现

  * 使用Seata框架基于TCC模式实现。

* **实现AP则要保证最终数据一致性:**
  * 使用消息队列通知的方式去实现，通知失败自动重试，达到最大失败次数需要人工处理；
  * 使用任务调度的方案，启动任务调度将课程信息由数据库同步到elasticsearch、MinIO、redis中。

## 课程发布的事务控制方案

回到课程发布，执行课程发布操作后要向数据库、redis、elasticsearch、MinIO写四份数据，这个场景用哪种方案？

> 满足CP？

如果要满足CP就表示课程发布操作后向数据库、redis、elasticsearch、MinIO写四份数据，**只要有一份写失败其它的全部回滚。**

> 满足AP？

课程发布操作后，先更新数据库中的课程发布状态，更新后向redis、elasticsearch、MinIO写课程信息，**只要在一定时间内最终向redis、elasticsearch、MinIO写数据成功即可。**

> 具体技术方案

目前我们已经有了任务调度的技术积累，这里选用任务调度的方案去实现分布式事务控制，课程发布满足AP即可。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-117.png)

1. 在内容管理服务的数据库中添加一个消息表，消息表和课程发布表在同一个数据库。

2. 点击课程发布通过本地事务向课程发布表写入课程发布信息，同时向消息表写课程发布的消息。通过数据库进行控制，只要课程发布表插入成功消息表也插入成功，消息表的数据就记录了某门课程发布的任务。

3. 启动任务调度系统定时调度内容管理服务去定时扫描消息表的记录。

4. 当扫描到课程发布的消息时即开始完成向redis、elasticsearch、MinIO同步数据的操作。

5. 同步数据的任务完成后删除消息表记录。

> 课程发布时序图

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-118.png)

1. 执行发布操作，内容管理服务存储课程发布表的同时向消息表添加一条“课程发布任务”。这里**使用本地事务保证课程发布信息保存成功，同时消息表也保存成功**。

2. 任务调度服务定时调度内容管理服务扫描消息表，由于课程发布操作后向消息表插入一条课程发布任务，此时扫描到一条任务。

3. 拿到任务开始执行任务，分别向redis、elasticsearch及文件系统存储数据。

4. 任务完成后删除消息表记录。

# 课程发布接口

## 接口定义

根据课程发布的分布式事务控制方案，课程发布操作首先通过本地事务向课程发布表写入课程发布信息并向消息表插入一条消息，这里定义的课程发布接口要实现该功能。

在内容管理接口工程中定义课程发布接口。

````java
@Controller
public class CoursePublishController {

    @ResponseBody
    @ApiOperation("课程发布")
    @PostMapping ("/coursepublish/{courseId}")
    public void coursepublish(@PathVariable("courseId") Long courseId){

    }

}
````

## 接口开发

> 课程发布操作对数据库操作如下：

1. 向课程发布表course_publish插入一条记录，记录来源于课程预发布表，如果存在则更新，发布状态为：已发布。

2. 更新course_base表的课程发布状态为：已发布

3. 删除课程预发布表的对应记录。

4. 向mq_message消息表插入一条消息，消息类型为：course_publish

> 约束：

1. 课程审核通过方可发布。

2. 本机构只允许发布本机构的课程。

> Service

```java
/**
 * 课程发布接口
 *
 * @param companyId 机构id
 * @param courseId 课程id
 */
void publish(Long companyId,Long courseId);
```

## 接口测试

```json
### 课程发布
POST {{content_host}}/content/coursepublish/2
```

先测试约束条件：

1、在未提交审核时进行课程发布测试。

2、在课程未审核通过时进行发布。

正常流程测试：

1、提交审核课程

2、手动修改课程预发布表与课程基本信息的审核状态为审核通过。

3、执行课程发布

4、观察课程发布表记录是否正常，课程预发布表记录已经删除，课程基本信息表与课程发布表的发布状态为”发布“。

使用前后端联调方式测试。

# 消息处理SDK

## 消息模块技术方案

课程发布操作执行后需要扫描消息表的记录，有关消息表处理的有哪些？

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-119.png)

上图中红色框内的都是与消息处理相关的操作：

1、新增消息表

2、扫描消息表。

3、更新消息表。

4、删除消息表。

使用消息表这种方式实现最终事务一致性的地方除了课程发布还有其它业务场景。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-120.png)

> 如果在每个地方都实现一套针对消息表定时扫描、处理的逻辑基本上都是重复的，软件的可复用性太低，成本太高。如何解决这个问题？

针对这个问题可以想到将消息处理相关的逻辑做成一个通用的东西。

是做成通用的服务，还是做成通用的代码组件呢？

* 通用的服务是完成一个通用的独立功能，并提供独立的网络接口，比如：项目中的文件系统服务，提供文件的分布式存储服务。

* 代码组件也是完成一个通用的独立功能，通常会提供API的方式供外部系统使用，比如：fastjson、Apache commons工具包等。

* 如果将消息处理做成一个通用的服务，该服务需要连接多个数据库，因为它要扫描微服务数据库下的消息表，并且要提供与微服务通信的网络接口，单就针对当前需求而言开发成本有点高。

* 如果将消息处理做一个SDK工具包相比通用服务不仅可以解决将消息处理通用化的需求，还可以降低成本。

所以，本项目确定**将对消息表相关的处理做成一个SDK组件供各微服务使用**，如下图所示：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-121.png)

> sdk需要提供执行任务的逻辑吗？

拿课程发布任务举例，执行课程发布任务是要向redis、索引库等同步数据，其它任务的执行逻辑是不同的，所以执行任务在sdk中不用实现任务逻辑，**只需要提供一个抽象方法由具体的执行任务方去实现**。

> 如何保证任务的幂等性？

任务执行完成后会从消息表删除，如果消息的状态是完成或不存在消息表中则不用执行。

> 如何保证任务不重复执行？

任务调度采用分片广播，根据分片参数去获取任务，另外阻塞调度策略为丢弃任务。

**注意：这里是信息同步类任务，即使任务重复执行也没有关系，不再使用抢占任务的方式保证任务不重复执行。**

> 还有一个问题，根据消息表记录是否存在或消息表中的任务状态去保证任务的幂等性，如果一个任务有好几个小任务，比如：课程发布任务需要执行三个同步操作：存储课程到redis、存储课程到索引库，存储课程页面到文件系统。如果其中一个小任务已经完成也不应该去重复执行。这里该如何设计？

将小任务作为任务的不同的阶段，在消息表中设计阶段状态。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-122.png)

每完成一个阶段在相应的阶段状态字段打上完成标记，即使这个大任务没有完成再重新执行时，如果小阶段任务完成了也不会重复执行某个小阶段的任务。

## 消息模块SDK测试

1、继承MessageProcessAbstract 抽象类编写任务执行方法

```java
@Slf4j
@Component
public class MessageProcessClass extends MessageProcessAbstract {

    @Resource
    private MqMessageService mqMessageService;

    @Override
    public boolean execute(MqMessage mqMessage) {
        Long id = mqMessage.getId();
        log.debug("开始执行任务:{}",id);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        // 取出阶段状态
        int stageOne = mqMessageService.getStageOne(id);
        if(stageOne<1){
            log.debug("开始执行第一阶段任务");
            System.out.println();
            int i = mqMessageService.completedStageOne(id);
            if(i>0){
                log.debug("完成第一阶段任务");
            }
        }else{
            log.debug("无需执行第一阶段任务");
        }
        return true;
    }
}
```

2、编写测试类

```java、

```

3、准备测试数据，在消息表添加消息类型为"test"的消息

4、执行MessageProcessClassTest 类中的test()方法，观察控制台任务执行的日志信息。

## 集成消息SDK

> 添加消息

1、内容管理service工程中添加sdk依赖

2、课程发布操作使用本地事务保存课程发布信息、添加消息表  

```java
@Override
public void publish(Long companyId, Long courseId) {

    // 查询课程预发布表
    CoursePublishPre coursePublishPre = coursePublishPreMapper.selectById(courseId);
    if (coursePublishPre == null) {
        BusinessException.cast("该课程没有审核记录，无法发布");
    }

    // 查询审核状态
    String status = coursePublishPre.getStatus();
    // 如果课程审核未通过，则不予通过
    if (!status.equals("202004")) {
        BusinessException.cast("该课程没有审核通过，无法发布");
    }

    // 向课程发布表写入数据
    CoursePublish coursePublish = new CoursePublish();
    BeanUtils.copyProperties(coursePublishPre, coursePublish);

    // 查询课程发布表。如果记录存在则进行更新，如果记录不存在，则进行添加
    CoursePublish coursePublishObj = coursePublishMapper.selectById(courseId);
    if (coursePublishObj == null) {
        coursePublishMapper.insert(coursePublish);
    } else {
        coursePublishMapper.updateById(coursePublish);
    }

    // 向消息表写入数据
    saveCoursePublishMessage(courseId);

    // 将课程预发布表的记录删除
    coursePublishPreMapper.deleteById(courseId);
}

/**
 * 保存消息表记录
 *
 * @param courseId 课程id
 */
private void saveCoursePublishMessage(Long courseId) {
    MqMessage mqMessage = mqMessageService.addMessage("course_publish", String.valueOf(courseId), null, null);

    if (mqMessage == null) {
        BusinessException.cast(CommonError.UNKOWN_ERROR);
    }
}
```

发布一门课程，观察消息表是否正常添加消息。

需要手动修改课程审核状态为审核通过执行发布操作，发布后可以修改发布状态为下架重新发布测试。

> 课程发布任务处理

```java

```

> 开启任务调度

在内容管理service工程中添加xxl-job依赖

```xml
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
</dependency>
```

配置执行器  

在nacos中在content-service-dev.yaml中配置

```java
xxl:
  job:
    admin: 
      addresses: http://localhost:8080/xxl-job-admin
    executor:
      appname: coursepublish-job
      address: 
      ip: 
      port: 8999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
    accessToken: default_token
```

从媒资管理服务层工程中拷贝一个XxlJobConfig配置类到内容管理service工程中。

在xxl-job-admin控制台中添加执行器

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-123.png)

编写任务调度入口

```java
@XxlJob("coursePublishJobHandler")
public void coursePublishJobHandler() throws Exception {

    // 分片参数
    int shardIndex = XxlJobHelper.getShardIndex(); // 执行器序号
    int shardTotal = XxlJobHelper.getShardTotal(); // 执行器总数

    // 调用抽象类的方法执行任务
    String messageType = "course_publish";
    int count = 30;
    long timeout = 60;

    process(shardIndex, shardTotal, messageType, count, timeout);
}
```

在xxl-job添加任务  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-124.png)

> 测试

在消息表添加课程发布的消息，消息类型为course_publish,business_key1为发布课程的ID

1、测试是否可以正常调度执行。

2、测试任务幂等性

在 saveCourseCache(mqMessage,courseId);处打断点，待执行到这里观察数据库第一阶段完成的标记预期标记为1。

结束进程，再重新启动，观察第一阶段的任务预期不再执行。

3、任务执行完成删除消息表记录，插入历史表，state状态字段为1

#  页面静态化

根据课程发布的操作流程，执行课程发布后要将课程详情信息页面静态化，生成html页面上传至文件系统。

## 页面静态化

课程预览功能通过模板引擎技术在页面模板中填充数据，生成html页面，这个过程是当客户端请求服务器时服务器才开始渲染生成html页面，最后响应给浏览器，服务端渲染的并发能力是有限的。

页面静态化则强调将生成html页面的过程提前，提前使用模板引擎技术生成html页面，当客户端请求时直接请求html页面，由于是静态页面可以使用nginx、apache等高性能的web服务器，并发性能高。

> 页面静态化技术使用场合

当数据变化不频繁，一旦生成静态页面很长一段时间内很少变化，此时可以使用页面静态化。因为如果数据变化频繁，一旦改变就需要重新生成静态页面，导致维护静态页面的工作量很大。

根据课程发布的业务需求，虽然课程发布后仍可以修改课程信息，但需要经过课程审核，且修改频度不大，所以适合使用页面静态化。

## 静态化测试

在内容管理service工程中添加freemarker依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-freemarker</artifactId>
</dependency>
```

编写测试方法

```java
@SpringBootTest
public class FreemarkerTest {

    @Resource
    private CoursePublishService coursePublishService;

    @Test
    public void testGenerateHtmlByTemplate() throws IOException, TemplateException {

        Configuration configuration = new Configuration(Configuration.getVersion());

        // classpath路径
        String classpath = this.getClass().getResource("/").getPath();
        // 模板目录
        configuration.setDirectoryForTemplateLoading(new File(classpath + "/templates/"));
        // 编码
        configuration.setDefaultEncoding("utf-8");
        // 模板
        Template template = configuration.getTemplate("course_template.ftl");
        // 数据
        CoursePreviewDto coursePreviewInfo = coursePublishService.getCoursePreviewInfo(1L);

        Map<String, Object> model = new HashMap<>();
        model.put("model", coursePreviewInfo);

        String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);
        InputStream inputStream = IOUtils.toInputStream(html, "utf-8");
        FileOutputStream outputStream = new FileOutputStream(new File("D:\\data\\upload\\1.html"));
        IOUtils.copy(inputStream, outputStream);
        
    }
}
```

## 上传文件测试

> 配置远程调用环境

 静态化生成文件后需要上传至分布式文件系统，根据微服务的职责划分，媒资管理服务负责维护文件系统中的文件，所以内容管理服务对页面静态化生成html文件需要调用媒资管理服务的上传文件接口  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-118.png)

微服务之间难免会存在远程调用，在Spring Cloud中可以使用Feign进行远程调用，Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign，其作用就是帮助我们优雅的实现http请求发送，解决上述问题

在内容管理content-service工程添加依赖：

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<!-- Spring Cloud 微服务远程调用 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-httpclient</artifactId>
</dependency>
<!--feign支持Multipart格式传参-->
<dependency>
    <groupId>io.github.openfeign.form</groupId>
    <artifactId>feign-form</artifactId>
    <version>3.8.0</version>
</dependency>
<dependency>
    <groupId>io.github.openfeign.form</groupId>
    <artifactId>feign-form-spring</artifactId>
    <version>3.8.0</version>
</dependency>
```

在nacos配置feign-dev.yaml公用配置文件

```yaml
feign:
  hystrix:
    enabled: true
  circuitbreaker:
    enabled: true
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 30000  #熔断超时时间
ribbon:
  ConnectTimeout: 60000 #连接超时时间
  ReadTimeout: 60000 #读超时时间
  MaxAutoRetries: 0 #重试次数
  MaxAutoRetriesNextServer: 1 #切换实例的重试次数
```

在内容管理service工程和内容管理api工程都引入此配置文件

```yaml
shared-configs:
  - data-id: feign-${spring.profiles.active}.yaml
    group: online-education-common
    refresh: true
```

在内容管理service工程配置feign支持Multipart  

```java
@Configuration
public class MultipartSupportConfig {

    @Resource
    private ObjectFactory<HttpMessageConverters> messageConverters;

    @Bean
    @Primary// 注入相同类型的bean时优先使用
    @Scope("prototype")
    public Encoder feignEncoder() {
        return new SpringFormEncoder(new SpringEncoder(messageConverters));
    }

    // 将file转为Multipart
    public static MultipartFile getMultipartFile(File file) {
        FileItem item = new DiskFileItemFactory().createItem("file", MediaType.MULTIPART_FORM_DATA_VALUE, true, file.getName());
        try (FileInputStream inputStream = new FileInputStream(file);
             OutputStream outputStream = item.getOutputStream();) {
            IOUtils.copy(inputStream, outputStream);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return new CommonsMultipartFile(item);
    }
}
```

扩充上传文件接口

现在需要将课程的静态文件上传到minio，单独存储到course目录下，文件的objectname为"课程id.html"，原有的上传文件接口需要增加一个参数 objectname。

```java
@ApiOperation("上传文件")
@RequestMapping(value = "/upload/coursefile",consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public UploadFileResultDto upload(@RequestPart("filedata") MultipartFile filedata,
                                  @RequestParam(value= "objectName",required=false) String objectName) throws IOException{
                                  //....
 }
```

修改相应Service方法，对于原有uploadFile方法，判断如果objectName为空则采取年月日样式的路径方式  

```java
//存储到minio中的对象名(带目录)
if(StringUtils.isEmpty(objectName)){
    objectName =  defaultFolderPath + fileMd5 + extension;
}
//        String objectName = defaultFolderPath + fileMd5 + extension;
```

远程调用测试

```java
@FeignClient(value = "media-api", configuration = {MultipartSupportConfig.class})
public interface MediaServiceClient {

    @RequestMapping(value = "/media/upload/coursefile",consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    String upload(@RequestPart("filedata") MultipartFile filedata,
                                      @RequestParam(value= "objectName",required=false) String objectName) throws IOException;

}
```

在启动类添加@EnableFeignClients注解

```java
@SpringBootApplication
@EnableFeignClients(basePackages = {"com.cyan.springcloud.content.feignclient"})
public class ContentServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ContentServiceApplication.class, args);
    }
}
```

编写测试方法

```java
@SpringBootTest
public class FeignUploadTest {

    @Autowired
    private MediaServiceClient mediaServiceClient;

    @Test
    public void testUpload() throws IOException {
        File file = new File("D:\\data\\upload\\1.html");
        MultipartFile multipartFile = MultipartSupportConfig.getMultipartFile(file);

        mediaServiceClient.upload(multipartFile, "course/1.html");
    }

}
```

启动媒资服务，执行测试方法，上传文件成功，进入minIO查看文件

同时访问http://localhost:9000/mediafiles/course/1.html是否可以正常访问

如果页面还没有样式，需要在nginx配置虚拟目录，在www.51xuecheng.cn下配置：



```text
		location /course/ {        
				proxy_pass  http://fileserver/mediafiles/course/;   
		}
```

访问 http://www.51xuecheng.cn/course/1.html  

## 熔断降级处理

微服务中难免存在服务之间的远程调用，比如：内容管理服务远程调用媒资服务的上传文件接口，当微服务运行不正常会导致无法正常调用微服务，此时会出现异常，如果这种异常不去处理可能导致雪崩效应。微服务的雪崩效应表现在服务与服务之间调用，当其中一个服务无法提供服务可能导致其它服务也挂掉

> 解决方案

可以采用熔断、降级的方法去解决。

熔断降级的相同点都是为了解决微服务系统崩溃的问题，但它们是两个不同的技术手段，两者又存在联系。

两者都是为了保护系统，**熔断是当下游服务异常时一种保护系统的手段，降级是熔断后上游服务处理熔断的方法。**

**熔断**：当下游服务异常而断开与上游服务的交互，它就相当于保险丝，**下游服务异常触发了熔断**，从而保证上游服务不受影响。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-125.png)

**降级**：当下游服务异常触发熔断后，**上游服务就不再去调用异常的微服务而是执行了降级处理逻辑**，这个降级处理逻辑可以是本地一个单独的方法。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-126.png)

> 熔断降级处理

项目使用Hystrix框架实现熔断、降级处理，在feign-dev.yaml中配置  

**开启熔断保护**

```yml
feign:
  hystrix:
    enabled: true
  circuitbreaker:
    enabled: true
```

**设置熔断的超时时间，为了防止一次处理时间较长触发熔断这里还需要设置请求和连接的超时时间**  

```yml
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 30000  #熔断超时时间
ribbon:
  ConnectTimeout: 60000 #连接超时时间
  ReadTimeout: 60000 #读超时时间
  MaxAutoRetries: 0 #重试次数
  MaxAutoRetriesNextServer: 1 #切换实例的重试次数
```

**定义降级逻辑**

> 降级方法1 fallback

定义一个fallback类MediaServiceClientFallback，此类实现了MediaServiceClient接口。

第一种方法**无法取出熔断所抛出的异常**，第二种方法定义MediaServiceClientFallbackFactory 可以解决这个问题。

```java
@FeignClient(value = "media-api", configuration = {MultipartSupportConfig.class}, fallback = MediaServiceClientFallback.class)
public interface MediaServiceClient {

    @RequestMapping(value = "/media/upload/coursefile", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    String upload(@RequestPart("filedata") MultipartFile filedata,
                  @RequestParam(value = "objectName", required = false) String objectName);
}
```

```java
public class MediaServiceClientFallback implements MediaServiceClient {

    @Override
    public String upload(MultipartFile filedata, String objectName) {
        return null;
    }
}
```

> 降级方法2  fallbackFactory   

第二种方法在FeignClient中指定fallbackFactory  

```java
@FeignClient(value = "media-api",configuration = MultipartSupportConfig.class,fallbackFactory = MediaServiceClientFallbackFactory.class)
```

```java
@Slf4j
@Component
public class MediaServiceClientFallbackFactory implements FallbackFactory<MediaServiceClient> {

    @Override
    public MediaServiceClient create(Throwable throwable) {
        // 发生熔断，上游服务调用此方法进行服务降级
        return new MediaServiceClient() {
            @Override
            public String upload(MultipartFile filedata, String objectName) {
                log.debug("调用媒资管理服务上传文件时发生熔断，异常信息:{}", throwable.toString(), throwable);
                return null;
            }
        };

    }
}
```

降级处理逻辑：

返回一个null对象，上游服务请求接口得到一个null说明执行了降级处理。

测试：

停止媒资管理服务或人为制造异常观察是否执行降级逻辑。

## 课程静态化开发

> 静态化实现

课程静态化包括两部分工作：生成课程静态化页面，上传静态页面到文件系统。

在课程发布的service编写这两部分内容，最后通过消息去调度执行。

```java
/**
 * 课程静态化
 *
 * @param courseId  课程id
 * @return File 静态化文件
 */
File generateCourseHtml(Long courseId);

/**
 * 上传课程静态化页面
 *
 * @param file  静态化文件
 */
void  uploadCourseHtml(Long courseId,File file);
```

```java
@Override
public File generateCourseHtml(Long courseId) {

    File htmlFile = null;
    Configuration configuration = new Configuration(Configuration.getVersion());
    try {
        // classpath路径
        String classpath = this.getClass().getResource("/").getPath();
        // 模板目录
        configuration.setDirectoryForTemplateLoading(new File(classpath + "/templates/"));
        // 编码
        configuration.setDefaultEncoding("utf-8");
        // 模板
        Template template = configuration.getTemplate("course_template.ftl");
        // 数据
        CoursePreviewDto coursePreviewInfo = this.getCoursePreviewInfo(courseId);

        Map<String, Object> model = new HashMap<>();
        model.put("model", coursePreviewInfo);

        String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);
        InputStream inputStream = IOUtils.toInputStream(html, "utf-8");
        htmlFile = File.createTempFile("coursepublish", ".html");
        FileOutputStream outputStream = new FileOutputStream(htmlFile);
        IOUtils.copy(inputStream, outputStream);
    } catch (Exception e) {
        log.error("页面静态化出现问题，课程id：{}", courseId, e);
        e.printStackTrace();
    }

    return htmlFile;
}

@Override
public void uploadCourseHtml(Long courseId, File file) {
   try {
       // file-->MultipartFile
       MultipartFile multipartFile = MultipartSupportConfig.getMultipartFile(file);
       // 远程调用媒资服务
       String upload = mediaServiceClient.upload(multipartFile, "course/" + courseId + ".html");
       if (upload == null) {
           log.info("该服务已经降级处理，课程id：{}", courseId);
           BusinessException.cast("上传静态文件过程中出现异常");
       }
   } catch (Exception e) {
       e.printStackTrace();
       BusinessException.cast("上传静态文件过程中出现异常");
   }
}
```

```java
private void generateCourseStaticHtml(MqMessage mqMessage, Long courseId) {

    // 消息id
    Long taskId = mqMessage.getId();
    MqMessageService mqMessageService = this.getMqMessageService();

    // 任务幂等性处理
    int stageOne = mqMessageService.getStageOne(taskId);
    if (stageOne > 0) {
        log.info("课程静态化任务完成，无需处理....");
        return;
    }

    // 开始进行课程静态化
    File file = coursePublishService.generateCourseHtml(courseId);
    if (file == null) {
        BusinessException.cast("生成的静态文件为空");
    }
    // 将生成的静态文件上传分布式文件系统
    coursePublishService.uploadCourseHtml(courseId, file);

    // 任务处理完成， 任务状态-->完成
    mqMessageService.completedStageOne(taskId);
}
```

> 测试

1.内容接口工程配置Feign

```java
@EnableSwagger2Doc
@SpringBootApplication(scanBasePackages = "com.cyan.springcloud.*")
@EnableFeignClients(basePackages = {"com.cyan.springcloud.content.feignclient"})
public class ContentApiApplication {
    public static void main(String[] args) {
        SpringApplication.run(ContentApiApplication.class, args);
    }
}
```

2.启动网关、媒资服务、内容管理服务

3.在CoursePublishTask类的execute方法中打上断点。

4.发布一门课程，保存消息表存在未处理的处理。

5.启动xxl-job调度中心、启动课程发布任务，等待定时调度，观察任务调度日志，观察任务是否可以正常处理  

6.处理完成进入文件系统，查询mediafiles桶内是否存在以课程id命名的html文件  

访问：http://www.51xuecheng.cn/course/1.html