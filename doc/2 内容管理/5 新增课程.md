# 1 需求分析

## 业务流程

课程相关的信息有：

* 课程基本信息
* 课程营销信息
* 课程图片信息
* 课程计划
* 课程师资信息

以下是业务流程：

1、进入课程查询列表

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-32.png)

2、点击添加课程，选择课程类型是直播还是录播。

3、选择完毕，点击下一步，进入课程基本信息添加界面。

本界面分两部分信息，一部分是课程基本信息上，一部分是课程营销信息。

课程基本信息：

![](C:/Users/dell/AppData/Roaming/Typora/typora-user-images/1677229981706.png)

课程营销信息：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-34.png)

4、在此界面填写课程计划信息

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-35.png)

课程计划即课程的大纲目录。

课程计划分为两级，章节和小节。

每个小节需要上传课程视频，用户点击 小节的标题即开始播放视频。

如果是直播课程则会进入直播间。

5、课程 计划填写完毕进入课程师资的管理。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-36.png)

## 数据模型

通过业务流程可知，一门课程信息涉及：课程基本信息、课程营销信息、课程计划信息、课程师资信息。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-37.png)

这两部分信息分别在course_base、course_market两张表存储。当点击保存按钮时向这两张表插入数据。这两张表是一对一关联关系。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-38.png)

新建课程的初始审核状态为“未提交”、初始发布状态为“未发布”。

# 2 接口定义

定义提交课程基本信息的接口。

1、接口协议 ：HTTP POST，Content-Type为application/json

2、请求及响应结果如下

> 请求参数

| 名称         | 类型    | 是否必须 | 默认值 | 备注                         | 其他          |
| ------------ | ------- | -------- | ------ | ---------------------------- | ------------- |
| charge       | string  | 是       |        | 收费规则，对应数据字典       |               |
| courseBaseld | integer | 否       |        | 课程id                       | format: int64 |
| description  | string  | 否       |        | 课程介绍                     |               |
| grade        | string  | 是       |        | 课程等级                     |               |
| mt           | string  | 是       |        | 大分类                       |               |
| name         | string  | 是       |        | 课程名称                     |               |
| pic          | string  | 是       |        | 课程图片                     |               |
| price        | number  | 否       |        | 价格                         |               |
| st           | string  | 是       |        | 小分类                       |               |
| tags         | string  | 否       |        | 课程标签                     |               |
| teachmode    | string  | 是       |        | 教学模式 (普通，录播，直播） |               |
| users        | string  | 是       |        | 适用人群                     |               |

> 返回数据

| 名称          | 类型    | 是否必须 | 默认值 | 备注                           | 其他              |
| ------------- | ------- | -------- | ------ | ------------------------------ | ----------------- |
| auditStatus   | string  | 否       |        | 审核状态：CourseAuditEnum      |                   |
| changeDate    | integer | 否       |        |                                | format: date-time |
| charge        | string  | 是       |        | 收费规则，对应数据字典         |                   |
| companyld     | integer | 否       |        | 机构ID                         | format: int64     |
| companyName   | string  | 否       |        | 机构名称                       |                   |
| courseBaseld  | integer | 否       |        |                                | format: int64     |
| createDate    | string  | 否       |        |                                | format: date-time |
| description   | string  | 否       |        | 课程介绍                       |                   |
| grade         | string  | 否       |        | 课程等级                       |                   |
| learners      | integer | 否       |        | 学习（报名）人数               | format: int32     |
| mt            | string  | 是       |        | 大分类                         |                   |
| mtName        | string  | 否       |        | 大分类名称                     |                   |
| name          | string  | 是       |        | 课程名称                       |                   |
| pic           | string  | 否       |        | 课程图片                       |                   |
| price         | number  | 否       |        | 价格                           |                   |
| st            | string  | 是       |        | 小分类                         |                   |
| stName        | string  | 否       |        | 小分类名称                     |                   |
| subsectionNum | integer | 否       |        | 任务数                         | format: int32     |
| tags          | string  | 否       |        | 课程标签                       |                   |
| teachmode     | string  | 是       |        | 教学模式（普通、录播、直播等） |                   |
| users         | string  | 是       |        | 适用人群                       |                   |

> 请求示例

```json
### 创建课程
POST {{content_host}}/content/course
Content-Type: application/json

{

  "mt": "",
  "st": "",
  "name": "",
  "pic": "",
  "teachmode": "200002",
  "users": "初级人员",
  "tags": "",
  "grade": "204001",
  "description": "",
  "objectives": "",
  "charge": "201000",
  "price": 0,
  "originalPrice":0,
  "qq": "",
  "wechat": "",
  "phone": "",
  "validDays": 365
}

###响应结果如下
#成功响应结果如下
{
  "id": 109,
  "companyId": 1,
  "companyName": null,
  "name": "测试课程103",
  "users": "初级人员",
  "tags": "",
  "mt": "1-1",
  "mtName": null,
  "st": "1-1-1",
  "stName": null,
  "grade": "204001",
  "teachmode": "200002",
  "description": "",
  "pic": "",
  "createDate": "2022-09-08 07:35:16",
  "changeDate": null,
  "createPeople": null,
  "changePeople": null,
  "auditStatus": "202002",
  "status": 1,
  "coursePubId": null,
  "coursePubDate": null,
  "charge": "201000",
  "price": null,
  "originalPrice":0,
  "qq": "",
  "wechat": "",
  "phone": "",
  "validDays": 365
}
```

3、定义请求参数类型和响应结构类型

# 3 接口开发

```java
/**
 * 添加课程基本信息
 *
 * @param companyId 教学机构id
 * @param addCourseDto 课程基本信息
 * @return 课程信息：基本信息、营销信息
 */
CourseBaseInfoDto createCourseBase(Long companyId, AddCourseDto addCourseDto);
```

```java
@Override
@Transactional
public CourseBaseInfoDto createCourseBase(Long companyId, AddCourseDto dto) {
    // 参数进行合法性校验
    if (StringUtils.isBlank(dto.getName())) {
        throw new RuntimeException("课程名称为空");
    }

    if (StringUtils.isBlank(dto.getMt())) {
        throw new RuntimeException("课程分类为空");
    }

    if (StringUtils.isBlank(dto.getSt())) {
        throw new RuntimeException("课程分类为空");
    }

    if (StringUtils.isBlank(dto.getGrade())) {
        throw new RuntimeException("课程等级为空");
    }

    if (StringUtils.isBlank(dto.getTeachmode())) {
        throw new RuntimeException("教育模式为空");
    }

    if (StringUtils.isBlank(dto.getUsers())) {
        throw new RuntimeException("适应人群为空");
    }

    if (StringUtils.isBlank(dto.getCharge())) {
        throw new RuntimeException("收费规则为空");
    }

    // 课程基本信息对象
    CourseBase courseBase = new CourseBase();
    // 将dto中属性名一样的属性值拷贝到courseBase
    BeanUtils.copyProperties(dto, courseBase);
    // 设置机构id
    courseBase.setCompanyId(companyId);
    // 设置创建时间
    courseBase.setCreateDate(LocalDateTime.now());
    // 设置审核状态，默认为未提交
    courseBase.setAuditStatus("202002");
    // 设置发布状态，默认为未发布
    courseBase.setStatus("203001");
    // 课程基本表插入记录
    int insertcourseBase = courseBaseMapper.insert(courseBase);
    // 获取课程id
    Long courseId = courseBase.getId();

    // 课程营销对象
    CourseMarket courseMarket = new CourseMarket();
    // 将dto中属性名一样的属性值拷贝到courseMarket
    BeanUtils.copyProperties(dto, courseMarket);
    courseMarket.setId(courseId);
    // 校验如果课程收费，价格必须输入
    String charge = dto.getCharge();
    if (charge.equals("201001")) { // 201001表示收费
        if (courseMarket.getPrice() == null || courseMarket.getPrice().floatValue() <= 0) {
            throw new RuntimeException("付费课程，但价格空");
        }
    }
    // 课程营销表插入记录
    int insertCourseMarket = courseMarketMapper.insert(courseMarket);

    // 判断插入是否成功
    if (insertcourseBase <= 0 || insertCourseMarket <= 0) {
        throw new RuntimeException("课程添加失败");
    }

    // 组装返回结果
    return getCourseBaseInfo(courseId);
}

/**
 * 根据课程id查询课程的基本信息和营销信息
 *
 * @param courseId
 * @return
 */
public CourseBaseInfoDto getCourseBaseInfo(Long courseId) {

    // 基本信息
    CourseBase courseBase = courseBaseMapper.selectById(courseId);

    // 营销信息
    CourseMarket courseMarket = courseMarketMapper.selectById(courseId);

    // 组装信息
    CourseBaseInfoDto courseBaseInfoDto = new CourseBaseInfoDto();
    BeanUtils.copyProperties(courseBase, courseBaseInfoDto);
    BeanUtils.copyProperties(courseMarket, courseBaseInfoDto);

    // 根据课程分类的id
    String mt = courseBase.getMt();
    String st = courseBase.getSt();

    CourseCategory mtCategory = courseCategoryMapper.selectById(mt);
    CourseCategory stCategory = courseCategoryMapper.selectById(st);
    if (mtCategory != null) {
        // 大分类名称
        String mtName = mtCategory.getName();
        courseBaseInfoDto.setMtName(mtName);
    }
    if (stCategory != null) {
        // 小分类名称
        String stName = stCategory.getName();
        courseBaseInfoDto.setName(stName);
    }

    return courseBaseInfoDto;
}
```

# 4 异常处理

> 需求：
>
> 当正常操作时按接口要求返回数据，当非正常流程时要获取异常信息进行记录，并提示给用户。

异常处理除了输出在日志中，还需要提示给用户，前端和后端需要作一些约定：

1、错误提示信息统一以json格式返回给前端。

2、以HTTP状态码决定当前是否出错，非200为操作异常。

> 规范异常信息

代码中统一抛出项目的自定义异常类型，这样可以统一去捕获这一类或几类的异常。

规范了异常类型就可以去获取异常信息。

如果捕获了非项目自定义的异常类型统一向用户提示“执行过程异常，请重试”的错误信息。

> 如何捕获异常

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-39.png)

​	

> 响应用户的统一类型

```java
public class RestErrorResponse implements Serializable {

    private String errMessage;

    public RestErrorResponse(String errMessage){
        this.errMessage= errMessage;
    }

    public String getErrMessage() {
        return errMessage;
    }

    public void setErrMessage(String errMessage) {
        this.errMessage = errMessage;
    }
}
```

> 自定义业务异常

```java
public class BusinessException extends RuntimeException {

    private String errMessage;

    public BusinessException() {
    }

    public BusinessException(String message) {
        super(message);
        this.errMessage = message;
    }

    public static void cast(CommonError commonError){
        throw new BusinessException(commonError.getErrMessage());
    }
    
    public static void cast(String errMessage){
        throw new BusinessException(errMessage);
    }
}
```

> 通用异常信息

```java
public enum CommonError {

   UNKOWN_ERROR("执行过程异常，请重试。"),
   PARAMS_ERROR("非法参数"),
   OBJECT_NULL("对象为空"),
   QUERY_NULL("查询结果为空"),
   REQUEST_NULL("请求参数为空");

   private String errMessage;

   public String getErrMessage() {
      return errMessage;
   }

   private CommonError( String errMessage) {
      this.errMessage = errMessage;
   }

}
```

> 全局异常处理器

从 Spring 3.0 - Spring 3.2 版本之间，对 Spring 架构和 SpringMVC 的Controller 的异常捕获提供了相应的异常处理。

- @ExceptionHandler

  Spring3.0提供的标识在方法上或类上的注解，用来表明方法的处理异常类型。

- @ControllerAdvice

  Spring3.2提供的新注解，从名字上可以看出大体意思是控制器增强，	在项目中来增强SpringMVC中的Controller。通常和**`@ExceptionHandler`** 结合使用，来处理SpringMVC的异常信息。

- @ResponseStatus

  Spring3.0提供的标识在方法上或类上的注解，用状态代码和应返回的原因标记方法或异常类。
  调用处理程序方法时，状态代码将应用于HTTP响应。

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 自定义异常
    @ExceptionHandler(BusinessException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse customException(BusinessException e) {
        // 记录异常
        log.error("系统异常{}", e.getErrMessage(), e);

        // 解析异常信息
        String errMessage = e.getErrMessage();
        return new RestErrorResponse(errMessage);
    }


    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse exception(BusinessException e) {
        // 记录异常
        log.error("系统异常{}", e.getErrMessage(), e);

        // 解析异常信息
        return new RestErrorResponse(CommonError.UNKOWN_ERROR.getErrMessage());
    }
}
```

# 5 JSR303校验

## 统一校验需求

Contoller中校验请求参数的合法性，包括：必填项校验，数据格式校验，比如：是否是符合一定的日期格式，等。

Service中要校验的是业务规则相关的内容，比如：课程已经审核通过所以提交失败。

Service中根据业务规则去校验不方便写成通用代码，Controller中则可以将校验的代码写成通用代码。

早在JavaEE6规范中就定义了参数校验的规范，它就是JSR-303，它定义了Bean Validation，即对bean属性进行校验。

SpringBoot提供了JSR-303的支持，它就是spring-boot-starter-validation，它的底层使用Hibernate Validator，Hibernate Validator是Bean Validation 的参考实现。

## 统一校验实现

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

对内容管理模块添加课程接口进行参数校验，此接口使用AddCourseDto模型对象接收参数，对AddCourseDto，在属性上添加校验规则。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-40.png)

定义好校验规则还需要开启校验，在controller方法中添加@Validated注解

如果校验出错Spring会抛出MethodArgumentNotValidException异常，我们需要在统一异常处理器中捕获异常，解析出异常信息。

## 分组校验

有时候在同一个属性上设置一个校验规则不能满足要求，比如：订单编号由系统生成，在添加订单时要求订单编号为空，在更新 订单时要求订单编写不能为空。此时就用到了分组校验，同一个属性定义多个校验规则属于不同的分组

用class类型来表示不同的分组，所以我们定义不同的接口类型（空接口）表示不同的分组，由于校验分组是公用的，所以定义在 base工程中

```java
public class ValidationGroups {

 public interface Insert{};
 public interface Update{};
 public interface Delete{};

}
```

```java
@NotEmpty(groups = {ValidationGroups.Insert.class},message = "添加课程名称不能为空")
 @NotEmpty(groups = {ValidationGroups.Update.class},message = "修改课程名称不能为空")
// @NotEmpty(message = "课程名称不能为空")
 @ApiModelProperty(value = "课程名称", required = true)
 private String name;
```

```java
@ApiOperation("新增课程基础信息")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(@RequestBody @Validated({ValidationGroups.Inster.class}) AddCourseDto addCourseDto){
    //机构id，由于认证系统没有上线暂时硬编码
    Long companyId = 1L;
  return courseBaseInfoService.createCourseBase(companyId,addCourseDto);
}
```

