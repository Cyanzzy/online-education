# 课程搜索

使用feign进行远程调用搜索服务时调用该服务的add方法

```java
@RequestMapping("/search")
@FeignClient(value = "search", fallbackFactory = SearchServiceClientFallbackFactory.class)
public interface SearchServiceClient {

    @PostMapping("/index/course")
    Boolean add(@RequestBody CourseIndex courseIndex);
}
```

但方法内的CourseIndex来自该工程，我直接引入该工程依赖导致项目报错（循环依赖）

报错：

无法从nacos中拿取配置项值

解决：

删除依赖，手动建立该模型

> 循环依赖

```java
class A{
 B b;
}
class B{
 A a;
}
//简单来说就是A的创建依赖于B，B的创建依赖于A。
```

 在⼀般场景下，如何解决循环依赖的问题？ 我们知道对象的创建⼀般有： 

* ⽆参构造器+属性Set⽅法初始化对象 
* 有参构造器直接初始化对象 

```java
// 通过有参构造器初始化
class A{
    B b;
    public A(B b) {
    this.b = b;
    }
}

class B{
    A a;
    public B(A a) {
    this.a = a;
    }
}
class client{
    //我们发现会⽆限套娃下去，有参构造器⽅法不能使⽤
    new A(new B(new A(new B())))
}
```

```java
//通过⽆参参构造器初始化
class A{
    B b;
    public void setB(B b) {
    this.b = b;
    }
}
class B{
    A a;
    public void setA(A a) {
    this.a = a;
    }
}
class client{
    //可以发现⽆参构造器+set⽅法可以完成任务
    A a = new a();
    B b = new b();
    a.setB(b);
    b.setA(a);
}
```

 通过上⾯的场景，我们就可以知道利⽤Set⽅法可以解决循环依赖，那 在Spring中也是如此 

> 在使⽤Spring时，常讲Spring容器，也就是我们不去new对象， ⽽是从容器中取对象，那这个容器到底是什么？ 

容器顾名思义，就是**存放数据对象**的地⽅，⼜是在内存中的，每次我们向容器⾥取对象时都会提供⼀个对象名，或者是类型信息，然后容器返回 相应的数据，那在Java基础中，我们学习到的Map结构，就很符合这样要 求，通过Key，Value来存储对象信息。

所以其实Spring容器就是通过⼀ 个Map来实现的，也就是这个家伙 `Map<String,Object> singletonObjects ` ,但更确切的来说它叫做**⼀级缓存**，**专⻔存放已经完整经过⽣命周期的对象**（对象初始化后，参数也赋值了）。

那既然有⼀级缓 存就可能有其他级缓存，确实Spring有三层缓存，⽽这三层缓存就是来解 决循环依赖的关键！！！ 

>  三级缓存为哪三级，分别是⼲嘛的 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-136.png)

 上图就Spring中的源码，三个Map对象的就是三级缓存 

*  **singletonObjects** ： ⼀级缓存存放完整⽣命周期的Bean，我们从容 器中取对象，就从这⾥找的。 

* **earlySingletonObjects** ： ⼆级缓存存放半⽣命周期的Bean，可以 理解为通过⽆参构造器想堆空间申请内存了，但是没有对属性赋值 

*  **singletonFactories** ： 三级缓存存放创建Bean的⼯⼚ 

 我们知道Spring容器中可以设置对象为多例模式和单例模式，每种模式 都可以解决循环依赖问题吗？ 

>  单例模式我们知道是存放在⼀级缓存中的，那prototype 模式的对象 是否也在⼀级缓存中？ 

*  我们可以看到为什么当变量设置为prototype时，每次返回的对象都不 ⼀样. 因为在Spring容器中根本没有缓存之前的对象，⽽是每次都实例⼀  个新的对象进⾏返回。 

* ⽽在单例模式时，会将对象放到缓存中，这样你下次再要对象时，直 接从⼀级缓存中找。 

> 那prototype能解决循环依赖问题吗？

 不能，因为假如说A类中有⼀个B属性需要注⼊，当实例化A时需要注⼊B，⽽B现在没有，需要先实例⼀个B对象，实例B的时候⼀个A注⼊，但容器中找不到之前创建的A，所以需要⾃⼰再实例⼀个A对象， 循环往复，因为每次返回的对象都不同。Spring官⽹也明确禁⽌ 了。 所以我们说Spring解决循环依赖的前提是对象是单例模式下的，并 通过Set⽅法构建。 

 所以我们说Spring解决循环依赖的前提是对象是单例模式下的，并 通过Set⽅法构建。  

>  那单例模式下是如何解决循环依赖的？ 

利⽤三层缓存来解决，现在容器需要注⼊⼀个A 对象时，先去⼀级缓存中找，没有的话则容器直接实例化⼀个A（没 有对属性赋值）并放⼊三级缓存，

当需要注⼊A对象的B时，也去容器 找，没有的话再实例化⼀个B，当给B对象的A赋值时，也去⼀级缓存找，没有则去⼆级缓存找，再没有去三级缓存，这时发现找到了之前的A，则直接注⼊，B这就算完整了放在⼀级缓存，

⼜回到A的初始化，去⼀级缓存找，发现有⼀个B，则对A也初始化。这样循环依赖就 解决掉了 

>  感觉似乎⼀层缓存也可以解决循环依赖问题，为什么Spring 要⽤三层？ 

 三级缓存是Spring在结合AOP跟Bean的⽣命周期的设计， 保证如果需要代理时，保证在Bean⽣命周期最后⼀步再完成代理。 

## 可参考

[Spring prototype 是采用原型模式吗？](https://blog.csdn.net/FanYien/article/details/117898188)

[Spring如何解决循环依赖](https://blog.csdn.net/oneby1314/article/details/113789384)

[三级缓存和循环依赖(不看点源码都看不懂)](https://juejin.cn/post/6930904292958142478)