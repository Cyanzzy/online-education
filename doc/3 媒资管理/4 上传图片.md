# 1 需求分析

> 业务流程

课程图片是宣传课程非常重要的信息，在新增课程界面上传课程图片，也可以修改课程图片  

课程图片上传至分布式文件系统，在课程信息中保存课程图片路径，如下流程：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-65.png)

1、前端进入上传图片界面

2、上传图片，请求媒资管理服务。

3、媒资管理服务将图片文件存储在MinIO。

4、媒资管理记录文件信息到数据库。

5、保存课程信息，在内容管理数据库保存图片地址。

用户上传图片请求至媒资管理的接口层，接口层解析文件信息通过业务层将文件保存至minio及数据库  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-66.png)

> 数据模型

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-67.png)

# 2 环境准备

在minio中配置两个bucket：`mediafiles`、`vedio`，并设置bucket的权限为public

在nacos配置中minio的相关信息，进入media-service-dev.yaml  

```yml
minio:
  endpoint: http://127.0.0.1:9000
  accessKey: minioadmin
  secretKey: minioadmin
  bucket:
    files: mediafiles
    videofiles: video
```

> minio配置

```java
@Configuration
public class MinioConfig {

    @Value("${minio.endpoint}")
    private String endpoint;
    @Value("${minio.accessKey}")
    private String accessKey;
    @Value("${minio.secretKey}")
    private String secretKey;

    @Bean
    public MinioClient minioClient() {
        MinioClient minioClient =
                MinioClient.builder()
                        .endpoint(endpoint)
                        .credentials(accessKey, secretKey)
                        .build();
        return minioClient;
    }
}
```

# 3 接口定义

根据需求分析，下边进行接口定义，此接口定义为一个通用的上传文件接口，可以上传图片或其它文件。

```json
请求地址：/media/upload/coursefile
请求参数：
Content-Type: multipart/form-data;boundary=.....
FormData:   filedata=??  
响应参数：文件信息，如下
{
  "id": "a16da7a132559daf9e1193166b3e7f52",
  "companyId": 1232141425,
  "companyName": null,
  "filename": "1.jpg",
  "fileType": "001001",
  "tags": "",
  "bucket": "/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg",
  "fileId": "a16da7a132559daf9e1193166b3e7f52",
  "url": "/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg",
  "timelength": null,
  "username": null,
  "createDate": "2022-09-12T21:57:18",
  "changeDate": null,
  "status": "1",
  "remark": "",
  "auditStatus": null,
  "auditMind": null,
  "fileSize": 248329
}
```

> 定义上传响应模型类：

```java
@Data
@ToString
public class UploadFileResultDto extends MediaFiles {
}
```

> 定义接口

```java
@ApiOperation("上传文件")
@RequestMapping(value = "/upload/coursefile",consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
@ResponseBody
public UploadFileResultDto upload(@RequestPart("filedata") MultipartFile upload,@RequestParam(value = "folder",required=false) String folder,@RequestParam(value = "objectName",required=false) String objectName) throws IOException {

}
```

# 4 接口开发

> 定义请求参数类  

```java
@Data
public class UploadFileParamsDto {
    
    /**
     * 文件名称
     */
    private String filename;

    /**
     * 文件content-type
     */
    private String contentType;

    /**
     * 文件类型（文档，音频，视频）
     */
    private String fileType;
    /**
     * 文件大小
     */
    private Long fileSize;

    /**
     * 标签
     */
    private String tags;

    /**
     * 上传人
     */
    private String username;

    /**
     * 备注
     */
    private String remark;
}
```

# 5 事务优化

> 原始uploadFile方法

```java
@Override
@Transactional
public UploadFileResultDto uploadFile(Long companyId, UploadFileParamsDto uploadFileParamsDto, String localFilePath) {

    // 文件名
    String filename = uploadFileParamsDto.getFilename();
    // 扩展名
    String extension = filename.substring(filename.lastIndexOf("."));
    // mimeType
    String mimeType = getMimeType(extension);
    // 子目录
    String defaultFolderPath = getDefaultFolderPath();
    // 文件md5
    String fileMd5 = getFileMd5(new File(localFilePath));
    String objectName = defaultFolderPath + fileMd5 + extension;
    // 上传文件到minio
    boolean result = addMediaFilesToMinIO(localFilePath, mimeType, bucketMediaFiles, objectName);

    if (!result) {
        BusinessException.cast("上传文件失败");
    }

    // 入库文件信息
    MediaFiles mediaFiles = addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucketMediaFiles, objectName);

    if (mediaFiles == null) {
        BusinessException.cast("文件上传后保存信息失败");
    }

    // 返回对象
    UploadFileResultDto uploadFileResultDto = new UploadFileResultDto();
    BeanUtils.copyProperties(mediaFiles, uploadFileResultDto);

    return uploadFileResultDto;
}
```

> 原始方法存在问题

目前如果在updateFile方法上添加`@Transactional`，当调用updateFile方法前会开启数据库事务，**如果上传文件过程时间较长（例如用户在上传超大视频文件），那么数据库的事务持续时间也会变长（因为在updateFile方法中，我们即要将文件上传到minio，又要将文件信息写入数据库）**，这样数据库连接释放就慢，最终导致数据库连接不够用

> 解决方案

 只在`addMediaFilesToDB`方法上添加事务控制即可，同时将uploadFile方法上的`@Transactional`注解去掉 

> 上述解决方案依然存在问题

Spring事务控制：判断方法能否被事务控制

1. 是不是通过**代理对象**调用的方法
2. 该方法上**是否添加**了`@Transactional`注解

当我们**在一个不能被事务控制的方法里（uploadFile），调用一个被事务控制的方法（addMediaFilesToDB），那么该方法（addMediaFilesToDB）也不会被事务控制**

> 提出新的解决方案

 需要通过代理对象去调用addMediaFilesToDB方法 ， 在MediaFileService的实现类中注入MediaFileService的代理对象 

```java
@Autowired
MediaFileService currentProxy;
```

 将addMediaFilesToDB方法提取成接口 

```java
/**
  * 将文件信息添加到文件表
  *
  * @param companyId           机构id
  * @param uploadFileParamsDto 上传文件的信息
  * @param objectName          对象名称
  * @param fileMD5             文件md5码
  * @param bucket              桶
  * @return
  */
 MediaFiles addMediaFilesToDB(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket);
```

 通过代理对象调用addMediaFilesToDB 

```java
MediaFiles mediaFiles = currentProxy.addMediaFilesToDB(companyId, uploadFileParamsDto, objectName, fileMD5, bucket_files);
```

