# 视频转码

> 视频编码

视频编码指通过压缩技术，将原始视频格式的文件转换成另一种视频格式文件的方式。

> FFmpeg 的基本使用

将视频录制完成后，使用视频编码软件对视频进行编码，本项目使用FFmpeg对视频进行编码  。FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。

# 分布式任务处理

> 高效处理一批任务

* 多线程

* 分布式+多线程

> 分布式任务调度

通常任务调度的程序是集成在应用中的，比如：优惠卷服务中包括了定时发放优惠卷的的调度程序，结算服务中包括了定期生成报表的任务调度程序，由于采用分布式架构，一个服务往往会部署多个冗余实例来运行我们的业务，在这种分布式系统环境下运行任务调度，我们称之为**分布式任务调度**  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-70.png)

> 分布式调度要实现的目标：

1. 并行任务调度

   如果将任务调度程序分布式部署，每个结点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率。

2. 高可用

   若某一个实例宕机，不影响其他实例来执行任务。

3. 弹性扩容

​       当集群中增加实例就可以提高并执行任务的处理效率。

4. 任务管理与监测

   对系统中存在的所有定时任务进行统一的管理及监测。让开发人员及运维人员能够时刻    了解任务执行情况，从而做出快速的应急处理响应。

5. 避免任务重复执行

   当任务调度以集群方式部署，同一个任务调度可能会执行多次，比如在上面提到的电商系统中到点发优惠券的例子，就会发放多次优惠券，对公司造成很多损失，所以我们需要控制相同的任务在多个运行实例上只执行一次。

> XXL-JOB 

XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。

官网：https://www.xuxueli.com/xxl-job/

XXL-JOB主要有调度中心、执行器、任务：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-71.png)

**调度中心：**

​    负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码；

​    主要职责为执行器管理、任务管理、监控运维、日志管理等

**任务执行器：**

​    负责接收调度请求并执行任务逻辑；

​    只要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等

**任务：**

   负责执行具体的业务处理

**调度中心：**

​    负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码；

​    主要职责为执行器管理、任务管理、监控运维、日志管理等

**任务执行器：**

​    负责接收调度请求并执行任务逻辑；

​    只要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等

**任务：**负责执行具体的业务处理

**调度中心与执行器之间的工作流程如下**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-72.png)

**执行流程：**

​    1.任务执行器根据配置的调度中心的地址，自动注册到调度中心

​    2.达到任务触发条件，调度中心下发任务

​    3.执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中

​    4.执行器消费内存队列中的执行结果，主动上报给调度中心

​    5.当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情

> 搭建XXL-JOB

[GitHub下载](https://github.com/xuxueli/xxl-job)

[Gitee下载](https://gitee.com/xuxueli0323/xxl-job)

[本项目使用XXL-JOB 2.3.1](https://github.com/xuxueli/xxl-job/releases/tag/2.3.1)



| 目录                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| xxl-job-admin            | 调度中心                                                     |
| xxl-job-core             | 公共依赖                                                     |
| xxl-job-executor-samples | 执行器Sample示例（选择合适的版本执行器，可直接使用）；xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；xxl-job-executor-sample-frameless：无框架版本； |

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-73.png)

执行sh /data/soft/restart.sh自动启动xxl-job调度中心

访问：http://localhost:8088/xxl-job-admin/

账号和密码：admin/123456

如果无法使用虚拟机运行xxl-job可以在本机idea运行xxl-job调度中心。

**执行器**

1. 进入调度中心添加执行器，点击新增，填写执行器信息，appname是前边在nacos中配置xxl信息时指定的执行器的应用名  

   ![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-74.png)

2.  在媒资管理模块的service工程添加依赖，在项目的父工程已约定了版本2.3.1  

   ```xml
   <dependency>
       <groupId>com.xuxueli</groupId>
       <artifactId>xxl-job-core</artifactId>
   </dependency>
   ```

3.  在nacos下的media-service-dev.yaml下配置xxl-job  

   ```yml
   xxl:
     job:
       admin: 
         addresses: http://localhost:8080/xxl-job-admin
       executor:
         appname: media-process-service
         address: 
         ip: 
         port: 9999
         logpath: /data/applogs/xxl-job/jobhandler
         logretentiondays: 30
       accessToken: default_token
   ```

   注意配置中的appname这是执行器的应用名，port是执行器启动的端口，如果本地启动多个执行器注意端口不能重复  

4. 配置xxl-job的执行器  

   ```java
   @Configuration
   public class XxlJobConfig {
       private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);
   
       @Value("${xxl.job.admin.addresses}")
       private String adminAddresses;
   
       @Value("${xxl.job.accessToken}")
       private String accessToken;
   
       @Value("${xxl.job.executor.appname}")
       private String appname;
   
       @Value("${xxl.job.executor.address}")
       private String address;
   
       @Value("${xxl.job.executor.ip}")
       private String ip;
   
       @Value("${xxl.job.executor.port}")
       private int port;
   
       @Value("${xxl.job.executor.logpath}")
       private String logPath;
   
       @Value("${xxl.job.executor.logretentiondays}")
       private int logRetentionDays;
   
   
       @Bean
       public XxlJobSpringExecutor xxlJobExecutor() {
           logger.info(">>>>>>>>>>> xxl-job config init.");
           XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
           xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
           xxlJobSpringExecutor.setAppname(appname);
           xxlJobSpringExecutor.setAddress(address);
           xxlJobSpringExecutor.setIp(ip);
           xxlJobSpringExecutor.setPort(port);
           xxlJobSpringExecutor.setAccessToken(accessToken);
           xxlJobSpringExecutor.setLogPath(logPath);
           xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
   
           return xxlJobSpringExecutor;
       }
   
       /**
        * 针对多网卡、容器内部署等情况，可借助 "spring-cloud-commons" 提供的 "InetUtils" 组件灵活定制注册IP；
        *
        *      1、引入依赖：
        *          <dependency>
        *             <groupId>org.springframework.cloud</groupId>
        *             <artifactId>spring-cloud-commons</artifactId>
        *             <version>${version}</version>
        *         </dependency>
        *
        *      2、配置文件，或者容器启动变量
        *          spring.cloud.inetutils.preferred-networks: 'xxx.xxx.xxx.'
        *
        *      3、获取IP
        *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();
        */
   
   
   }
   ```

   到此完成媒资管理模块service工程配置xxl-job执行器，在xxl-job调度中心添加执行器，下边准备测试执行器与调度中心是否正常通信，因为接口工程依赖了service工程，所以启动媒资管理模块的接口工程。

**执行任务**

1. 在媒资服务service包下新建jobhandler存放任务类  

    ```java
    @Slf4j
    @Component
    public class SampleXxlJob {

        @XxlJob("demoHandler")
        public void demoHandler() throws Exception {
            log.info("处理视频>>>>>>>>>>>>>>>>>>>");
        }

    }
    ```

2. 在调度中心添加任务，进入任务管理  

   ![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-75.png)

3. 添加成功，启动任务，通过调度日志查看任务执行情况

**分片广播**

>   XXL-JOB 高级配置： 

   - 路由策略：当执行器集群部署时，提供丰富的路由策略，包括；
     FIRST（第一个）：固定选择第一个机器；
     LAST（最后一个）：固定选择最后一个机器；
     ROUND（轮询）：；
     RANDOM（随机）：随机选择在线的机器；
     CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。
     LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；
     LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；
     FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；
     BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；
     SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；

   - 子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度，通过子任务可以实现一个任务执行完成去执行另一个任务。
   - 调度过期策略：
     - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；
     - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；
   
   -  阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；
       * 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；
       * 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；
     * 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；
- 任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；
- 失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；  

> 分片广播

分片是指是调度中心以执行器为维度进行分片，将集群中的执行器标上序号：0，1，2，3...，广播是指每次调度会向集群中的所有执行器发送任务调度，请求中携带分片参数。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-76.png)

每个执行器收到调度请求同时接收分片参数。xxl-job支持动态扩容执行器集群从而动态增加分片数量，当有任务量增加可以部署更多的执行器到集群中，调度中心会动态修改分片的数量。

**作业分片适用场景**

•     分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；

•     广播任务场景：广播执行器同时运行shell脚本、广播集群节点进行缓存更新等。

所以，广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群分布式处理任务。

**使用说明：**

"分片广播" 和普通任务开发流程一致，不同之处在于可以获取分片参数进行分片业务处理。

Java语言任务获取分片参数方式：BEAN、GLUE模式(Java)

模拟集群：

在nacos中配置media-service的本地优先配置：  

```yml
#配置本地优先
spring:
 cloud:
  config:
    override-none: true
```

实例1 在VM options处添加：-Dserver.port=63051 -Dxxl.job.executor.port=9998

实例2 在VM options处添加：-Dserver.port=63050 -Dxxl.job.executor.port=9999

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-77.png)

1.定义作业分片的任务方法

```java
/**
 * 2、分片广播任务
 */
@XxlJob("shardingJobHandler")
public void shardingJobHandler() throws Exception {

    // 分片参数
    int shardIndex = XxlJobHelper.getShardIndex(); // 执行器序号，从0开始
    int shardTotal = XxlJobHelper.getShardTotal(); // 执行器总数

    log.info("分片参数：当前分片序号 = {}, 总分片数 = {}", shardIndex, shardTotal);
    log.info("开始执行第"+shardIndex+"批任务");

}
```

2.在调度中心添加任务，添加成功，启动并查看日志

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-78.png)

# 技术方案

> 作业分片

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-80.png)

 每个执行器收到广播任务有两个参数：分片总数、分片序号。每个执行从数据表取任务时可以让任务id 模上 分片总数，如果等于分片序号则执行此任务  

> 任务不重复执行

**调度过期策略** ：调度中心错过调度时间的补偿处理策略  

* 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间
* 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间  

结论：使用“忽略”策略

**阻塞处理策略**  ：调度过于密集执行器来不及处理时的处理策略  

* 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行 
* 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败   

* 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务  

结论：如果选择覆盖之前调度则可能重复执行任务，这里选择 丢弃后续调度或单机串行方式来避免任务重复执行  

**幂等性**：它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果  

对于数据的操作不论多少次，操作的结果始终是一致的。在本项目中要实现的是不论多少次任务调度同一个视频只执行一次成功的转码  

幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。

解决幂等性常用的方案：

1）数据库约束，比如：唯一索引，主键。

2）乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。

3）唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等则执行。

结论： 在执行器接收调度请求去执行视频处理任务时要实现视频处理的幂等性，要有判断该视频是否处理完成，如果正在处理中或处理完则不再处理。在数据库视频处理表中添加处理状态字段，视频处理完成更新状态为完成，执行视频处理前判断状态是否完成，如果完成则不再处理  

> 视频处理方案

确定分片方案后，整个视频上传和处理的业务流程如下，上传视频成功向视频处理待处理表添加记录。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-79.png)

视频处理的详细流程如下：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-81.png)

1. 任务调度中心广播作业分片。

2. 执行器收到广播作业分片，从数据库读取待处理任务，读取未处理及处理失败的任务。

3. 执行器更新任务为处理中，根据任务内容从MinIO下载要处理的文件。

4. 执行器启动多线程去处理任务。

5. 任务处理完成，上传处理后的视频到MinIO。

6. 将更新任务处理结果，如果视频处理完成除了更新任务处理结果以外还要将文件的访问地址更新至任务处理表及文件表中，最后将任务完成记录写入历史表。

# 查询待处理任务

## 需求分析

查询待处理任务只处理未提交及处理失败的任务，任务处理失败后进行重试，最多重试3次。任务处理成功将待处理记录移动到历史任务表。



## 添加待处理任务

上传视频成功向视频处理待处理表添加记录，暂时只添加对avi视频的处理记录。

根据MIME TypeaviMIME Type

|   Video Type   | Extension |       MIME Type       |
| :------------: | :-------: | :-------------------: |
|     Flash      |   .flv    |      video/x-flv      |
|     MPEG-4     |   .mp4    |       video/mp4       |
|  iPhone Index  |   .m3u8   | application/x-mpegURL |
| iPhone Segment |    .ts    |      video/MP2T       |
|   3GP Mobile   |   .3gp    |      video/3gpp       |
|   QuickTime    |   .mov    |    video/quicktime    |
| A/V Interleave |   .avi    |    video/x-msvideo    |
| Windows Media  |   .wmv    |    video/x-ms-wmv     |

## 查询待处理任务

```java

public interface MediaProcessMapper extends BaseMapper<MediaProcess> {

    /**
     * 根据分片参数获取待处理任务
     *
     * @param shardTotal 分片总数
     * @param shardIndex 分片序号
     * @param count 任务数
     * @return
     */
    List<MediaProcess> selectListByShardIndex(@Param("shardTotal") int shardTotal, @Param("shardIndex") int shardIndex, @Param("count") int count);
}
```

```xml
<select id="selectListByShardIndex" resultType="com.cyan.springcloud.media.model.po.MediaProcess">
  SELECT * FROM media_process t
  WHERE t.id % #{shardTotal} = #{shardIndex}
  AND (t.status = '1' OR t.status = '3')
  AND t.fail_count &gt; 3
  LIMIT #{count}
</select>
```

# 开始执行任务

## 分布式锁

为了避免多线程去争抢同一个任务可以使用synchronized同步锁去解决 ，synchronized只能保证同一个虚拟机中多个线程去争抢锁。

如果是多个执行器分布式部署，并不能保证同一个视频只有一个执行器去处理。

现在要实现分布式环境下所有虚拟机中的线程去同步执行就需要让多个虚拟机去共用一个锁，虚拟机可以分布式部署，锁也可以分布式部署  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-82.png)

* 基于数据库实现分布锁

  利用数据库主键唯一性的特点，或利用数据库唯一索引、行级锁的特点，多个线程同时去更新相同的记录，谁更新成功谁就抢到锁。

* 基于redis实现锁

  redis提供了分布式锁的实现方案，比如：SETNX、set nx、redisson等。

* 使用zookeeper实现

  zookeeper是一个分布式协调服务，主要解决分布式程序之间的同步的问题。zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁。

## 开启任务

> 基于数据库方式实现分布式锁

使用乐观锁实现多线程抢锁

```sql
update media_process m set m.status='4' where (m.status='1' or m.status='3') and m.fail_count<3 and m.id=?
```

```java
/**
 * 开启一个任务
 *
 * @param id 任务id
 * @return 更新记录数
 */
int startTask(@Param("id") long id);
```

````xml
<update id="startTask">
    UPDATE media_process m
    SET m.status = '4'
    WHERE (m.status = '1' OR m.status = '3')
    AND m.fail_count &lt; 3
    AND m.id = ?
</update>
````

## 更新任务状态

任务处理完成需要更新任务处理结果，任务执行成功更新视频的URL、及任务处理结果，将待处理任务记录删除，同时向历史任务表添加记录  