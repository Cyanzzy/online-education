# 1 需求分析

1.教学机构人员进入媒资管理列表查询自己上传的媒资文件 ，点击“媒资管理”，进入媒资管理列表页面查询本机构上传的媒资文件。

2.教育机构用户在"媒资管理"页面中点击 "上传视频" 按钮。点击“上传视频”打开上传页面

3.选择要上传的文件，自动执行文件上传  

4.视频上传成功会自动处理，处理完成可以预览视频  

# 2 断点续传

 断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性  

> 断点续传

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-68.png)

1. 前端上传前先把文件分成块  

2. 一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传  
3. 各分块上传完成最后在服务端合并文件  

> 文件分块测试

1. 获取源文件长度

2. 根据设定的分块文件的大小计算出块数

3. 从源文件读数据依次向每一个块文件写数据

```java
@Test
public void testChunk() throws Exception {
    // 源文件
    File sourceFile = new File("D:\\data\\upload\\测试文件.mp4");
    // 分块文件存储路径
    String chunkFilePath = "D:\\data\\upload\\chunk\\";
    // 分块文件大小
    int chunkSize = 1024 * 1024 * 5; // 5M
    // 分块文件个数
    int chunkNum = (int) Math.ceil(sourceFile.length() * 1.0 / chunkSize);
    // 使用流从源文件读取数据，向分块文件中读写数据
    RandomAccessFile file_r = new RandomAccessFile(sourceFile, "r");
    // 缓冲区
    byte[] bytes = new byte[1024];
    for (int i = 0; i < chunkNum; i++) {
        File chunckFile = new File(chunkFilePath + i);
        // 分块文件写入流
        RandomAccessFile file_rw = new RandomAccessFile(chunckFile, "rw");
        int len = -1;
        while ((len = file_r.read(bytes)) != -1) {
            file_rw.write(bytes, 0, len);
            if (chunckFile.length() >= chunkSize) {
                break;
            }
        }
        file_rw.close();
    }
    file_r.close();
}
```

> 文件合并测试

1. 找到要合并的文件并按文件合并的先后进行排序。

2. 创建合并文件

3. 依次从合并的文件中读取数据向合并文件写入数

```java
@Test
public void testMerge() throws Exception{
    // 分块文件目录
    File chunkFolder = new File("D:\\data\\upload\\chunk");
    // 源文件
    File sourceFile = new File("D:\\data\\upload\\测试文件.MP4");
    // 合并后的文件
    File mergeFile = new File("D:\\data\\upload\\合并后的文件.mp4");

    // 取出所有分块文件
    File[] files = chunkFolder.listFiles();
    List<File> filesList = Arrays.asList(files);
    // 对分块文件进行排序
    Collections.sort(filesList, (o1, o2) -> Integer.parseInt(o1.getName()) - Integer.parseInt(o2.getName()));

    RandomAccessFile file_rw = new RandomAccessFile(mergeFile, "rw");

    byte[] bytes = new byte[1024];

    for (File file : filesList) {
        RandomAccessFile file_r = new RandomAccessFile(file, "r");
        int len = -1;
        while ((len = file_r.read(bytes)) != -1) {
            file_rw.write(bytes, 0, len);
        }
        file_r.close();
    }
    file_rw.close();

    // 校验
    String merge = DigestUtils.md5Hex(new FileInputStream(mergeFile));
    String source = DigestUtils.md5Hex(new FileInputStream(sourceFile));

    if (merge.equals(source)) {
        System.out.println("merge success");
    }

}
```

> 上传视频流程

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-69.png)

1. 前端上传文件前请求媒资接口层检查文件是否存在，如果已经存在则不再上传。

2. 如果文件在系统不存在前端开始上传，首先对视频文件进行分块

3. 前端分块进行上传，上传前首先检查分块是否上传，如已上传则不再上传，如果未上传则开始上传分块。

4. 前端请求媒资管理接口层请求上传分块。

5. 接口层请求服务层上传分块。

6. 服务端将分块信息上传到MinIO。

7. 前端将分块上传完毕请求接口层合并分块。

8. 接口层请求服务层合并分块。

9. 服务层根据文件信息找到MinIO中的分块文件，下载到本地临时目录，将所有分块下载完毕后开始合并 。

10. 合并完成将合并后的文件上传到MinIO。

# 3 接口定义

```java
@Api(value = "大文件上传接口", tags = "大文件上传接口")
@RestController
public class BigFilesController {

    @Resource
    private MediaFileService mediaFileService;


    @ApiOperation(value = "文件上传前检查文件")
    @PostMapping("/upload/checkfile")
    public RestResponse<Boolean> checkfile(@RequestParam("fileMd5") String fileMd5) throws Exception {
        return null;
    }


    @ApiOperation(value = "分块文件上传前的检测")
    @PostMapping("/upload/checkchunk")
    public RestResponse<Boolean> checkchunk(@RequestParam("fileMd5") String fileMd5, @RequestParam("chunk") int chunk) throws Exception {
        return null;
    }

    @ApiOperation(value = "上传分块文件")
    @PostMapping("/upload/uploadchunk")
    public RestResponse uploadchunk(@RequestParam("file") MultipartFile file, @RequestParam("fileMd5") String fileMd5, @RequestParam("chunk") int chunk) throws Exception {

        return null;
    }

    @ApiOperation(value = "合并文件")
    @PostMapping("/upload/mergechunks")
    public RestResponse mergechunks(@RequestParam("fileMd5") String fileMd5, @RequestParam("fileName") String fileName, @RequestParam("chunkTotal") int chunkTotal) throws Exception {
        return null;

    }

}
```

# 4 接口开发

## Service

> 检查文件和分块

```java
/**
 * 检查文件是否存在
 *
 * @param fileMd5 文件的md5
 */
RestResponse<Boolean> checkFile(String fileMd5);

/**
 * 检查分块是否存在
 *
 * @param fileMd5  文件的md5
 * @param chunkIndex  分块序号
 */
RestResponse<Boolean> checkChunk(String fileMd5, int chunkIndex);
```

判断文件是否存在

- 首先判断数据库中是否存在该文件
- 其次判断minio的bucket中是否存在该文件

```java
@Override
public RestResponse<Boolean> checkFile(String fileMd5) {
    // 先查询数据库
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5);
    if (mediaFiles == null) {
        // 文件不存在
        return RestResponse.success(false);
    }

    // 如果数据库存在，再查询minio
    try {
        FilterInputStream inputStream = minioClient.getObject(GetObjectArgs
                .builder()
                .bucket(mediaFiles.getBucket())
                .build());
        if (inputStream == null) {
            return RestResponse.success(false);
        }
    } catch (Exception e) {
        return RestResponse.success(false);
    }
    return RestResponse.success(true);
}
```

```java
@Override
public RestResponse<Boolean> checkChunk(String fileMd5, int chunkIndex) {

    // 获取分块目录
    String chunkFileFolderPath = getChunkFileFolderPath(fileMd5);
    String chunkFilePath = chunkFileFolderPath + chunkIndex;

    // 检查分块是否存在
    try {
        FilterInputStream inputStream = minioClient.getObject(GetObjectArgs
                .builder()
                .bucket(bucketVideo)
                .object(chunkFilePath)
                .build());
        if (inputStream == null) {
            // 文件不存在
            return RestResponse.success(false);
        }
    } catch (Exception e) {
        e.printStackTrace();
        return RestResponse.success(false);
    }
    // 文件存在
    return RestResponse.success(true);
}

/**
 * 得到分块文件的目录
 * 分块存储路径：md5前两位为两个目录，chunk存储分块文件
 *
 * @param fileMd5
 * @return
 */
private String getChunkFileFolderPath(String fileMd5) {
    return fileMd5.substring(0, 1) + "/" + fileMd5.substring(1, 2) + "/" + fileMd5 + "/" + "chunk" + "/";
}
```

> 上传分块

```java
/**
 * 上传分块
 *
 * @param fileMd5  文件md5
 * @param chunk  分块序号
 * @param localChunkFilePath  文件路径
 */
RestResponse uploadChunk(String fileMd5, int chunk, String localChunkFilePath);
```

```java
@Override
public RestResponse uploadChunk(String fileMd5, int chunk, String localChunkFilePath) {

    // 分块文件的路径
    String chunkFilePath = getChunkFileFolderPath(fileMd5) + chunk;
    // mimeType
    String mimeType = getMimeType(null);
    // 将分块文件上传到minio
    boolean result = addMediaFilesToMinIO(localChunkFilePath, mimeType, bucketVideo, chunkFilePath);

    if (!result) {
        return RestResponse.validfail(false, "上传分块文件失败");
    }

    return RestResponse.success(true);
}
```

> 合并分块

```java
@Override
public RestResponse mergeChunks(Long companyId, String fileMd5, int chunkTotal, UploadFileParamsDto uploadFileParamsDto) {
    // 找到分块文件进行合并

    // 分块文件所在目录
    String chunkFileFolderPath = getChunkFileFolderPath(fileMd5);
    // 分块文件信息
    List<ComposeSource> sources = Stream.iterate(0, i -> ++i)
            .limit(chunkTotal)
            .map(i -> ComposeSource.builder().bucket(bucketVideo).object(chunkFileFolderPath + i).build())
            .collect(Collectors.toList());
    // 源文件名称
    String filename = uploadFileParamsDto.getFilename();
    // 扩展名
    String extension = filename.substring(filename.lastIndexOf("."));
    // 合并后文件的objectName
    String objectName = getFilePathByMd5(fileMd5, extension);

    // 参数信息
    ComposeObjectArgs composeObjectArgs = ComposeObjectArgs.builder()
            .bucket(bucketVideo)
            .object(objectName) // 合并后的文件
            .sources(sources) // 指定源文件
            .build();
    // 合并文件 minio 分块默认5M
    try {
        minioClient.composeObject(composeObjectArgs);
    } catch (Exception e) {
        e.printStackTrace();
        log.error("合并文件出错, bucket:{},objectName:{},错误信息:{}",bucketVideo, objectName, e.getMessage());
        return RestResponse.validfail(false, "合并文件出错");
    }
    // 下载合并后的文件
    File file = downloadFileFromMinIO(bucketVideo, objectName);
    // 校验合并后的文件和源文件是否一致
    try (FileInputStream fileInputStream = new FileInputStream(file)){
        // 计算合并后的文件的md5
        String mergeFileMd5 = DigestUtils.md5Hex(fileInputStream);
        // 比较源文件的md5值
        if (!fileMd5.equals(mergeFileMd5)) {
            log.error("校验合并文件的md5和原始文件md5不一致, 合并文件:{}, 原始文件:{}", mergeFileMd5, fileMd5);
            return RestResponse.validfail(false, "文件校验失败");
        }
        // 文件大小
        uploadFileParamsDto.setFileSize(file.length());
    } catch (Exception e) {
        return RestResponse.validfail(false, "文件校验失败");
    }
    // 将文件信息保存到数据库（非事务方法调用事务方法通过代理对象去调用，否则事务会失效）
    MediaFiles mediaFiles = currentProxy.addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucketVideo, objectName);
    if (mediaFiles == null) {
        return RestResponse.validfail(false, "文件府库失败");
    }
    // 清理分块文件
    clearChunkFiles(chunkFileFolderPath, chunkTotal);

    return RestResponse.success(true);
}
```

## Controller

> 上传分块

```java
@ApiOperation(value = "文件上传前检查文件")
@PostMapping("/upload/checkfile")
public RestResponse<Boolean> checkfile(@RequestParam("fileMd5") String fileMd5) throws Exception {
    return mediaFileService.checkFile(fileMd5);
}


@ApiOperation(value = "分块文件上传前的检测")
@PostMapping("/upload/checkchunk")
public RestResponse<Boolean> checkchunk(@RequestParam("fileMd5") String fileMd5, @RequestParam("chunk") int chunk) throws Exception {
    return mediaFileService.checkChunk(fileMd5, chunk);
}

@ApiOperation(value = "上传分块文件")
@PostMapping("/upload/uploadchunk")
public RestResponse uploadchunk(@RequestParam("file") MultipartFile file, @RequestParam("fileMd5") String fileMd5, @RequestParam("chunk") int chunk) throws Exception {

    // 创建临时文件
    File tempFile = File.createTempFile("minio", ".temp");
    file.transferTo(tempFile);
    String localFilePath = tempFile.getAbsolutePath();

    return mediaFileService.uploadChunk(fileMd5, chunk, localFilePath);
}
```

> 合并分块

```java
@ApiOperation(value = "合并文件")
@PostMapping("/upload/mergechunks")
public RestResponse mergechunks(@RequestParam("fileMd5") String fileMd5, @RequestParam("fileName") String fileName, @RequestParam("chunkTotal") int chunkTotal) throws Exception {
    Long companyId = 1232141425L;
    // 文件信息对象
    UploadFileParamsDto uploadFileParamsDto = new UploadFileParamsDto();
    uploadFileParamsDto.setFilename(fileName);
    uploadFileParamsDto.setTags("视频文件");
    uploadFileParamsDto.setFileType("001002");

    return mediaFileService.mergeChunks(companyId, fileMd5, chunkTotal, uploadFileParamsDto);
}
```

