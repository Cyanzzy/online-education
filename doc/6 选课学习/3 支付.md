# 需求分析

## 执行流程

用户去学习收费课程时引导其去支付

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-194.png)

> 用户点击“微信支付”或支付宝支付时执行流程

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-195.png)

1. 请求学习中心服务创建选课记录

2. 请求订单服务创建商品订单、生成支付二维码。

3. 用户扫码请求订单支付服务，订单支付服务请求第三方支付平台生成支付订单。

4. 前端唤起支付客户端，用户输入密码完成支付。

5. 第三方支付平台支付完成发起支付通知。

6. 订单支付服务接收第三方支付通知结果。

7. 用户在前端查询支付结果，请求订单支付服务查询支付结果。

8. 订单支付服务向学习中心服务通知支付结果。

9. 学习中心服务收到支付结果，如果支付成功则更新选课记录，并添加到我的课程表。

## 通用订单服务设计

在本项目中不仅选课需要下单、购买学习资料、老师一对一答疑等所以收费项目都需要下单支付。

所以本项目设计通用的订单服务，通用的订单服务承接各业务模块的收费支付需求，当用户需要交费时统一生成商品订单并进行支付。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-196.png)

所有收费业务最终转换为商品订单记录在订单服务的商品订单表  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-197.png)

以选课为例，选课记录表的ID记录在商品订单表的out_business_id字段  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-198.png)

# 准备开发环境

## 支付宝开发环境

1. 配置沙箱环境

   沙箱环境是支付宝开放平台为开发者提供的与生产环境完全隔离的联调测试环境，开发者在沙箱环境中完成的接口调用不会对生产环境中的数据造成任何影响。

   详细参见： https://opendocs.alipay.com/common/02kkv7 

2. 安装模拟器

   下载模拟器：http://mumu.163.com/

3. 在模拟器中安装沙箱版本的支付宝

   使用沙箱环境的买家账号登录沙箱版本的支付宝

## 创建订单服务

导入数据库，修改配置，导入nacos

# 支付宝接口测试

## 阅读接口定义

手机网站支付接入流程详细参见：https://docs.open.alipay.com/203/105285/

> 1、接口交互流程如下：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-201.png)

1. 用户在商户的H5网站下单支付后，商户系统按照[手机网站支付接口alipay.trade.wap.pay](https://docs.open.alipay.com/203/107090)API的参数规范生成订单数据

2. 前端页面通过Form表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝H5收银台页面，如果用户手机上安装了支付宝APP，则自动唤起支付宝APP。

3. 输入支付密码完成支付。

4. 用户在支付宝APP或H5收银台完成支付后，会根据商户在手机网站支付API中传入的前台回跳地址return_url自动跳转回商户页面，同时在URL请求中以Query String的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口alipay.trade.wap.pay”[前台回跳参数](https://docs.open.alipay.com/203/107090#s2)。

5. 支付宝还会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统，详情见[支付结果异步通知](https://docs.open.alipay.com/203/105286)。

> 接口定义

文档：https://opendocs.alipay.com/open/203/107090

接口定义：外部商户请求支付宝创建订单并支付

**请求地址使用沙箱地址**：https://openapi.alipaydev.com/gateway.do

请求参数阅读官方文档：https://opendocs.alipay.com/open/203/107090

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-202.png)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-203.png)

> 3、示例代码

```java
public void doPost(HttpServletRequest httpRequest,
                   HttpServletResponse httpResponse) throws ServletException, IOException {
    AlipayClient alipayClient = ... //获得初始化的AlipayClient
    AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
    alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
    alipayRequest.setNotifyUrl("http://domain.com/CallBack/notify_url.jsp");//在公共参数中设置回跳和通知地址
    alipayRequest.setBizContent("{" +
            "    \"out_trade_no\":\"20150320010101002\"," +
            "    \"total_amount\":88.88," +
            "    \"subject\":\"Iphone6 16G\"," +
            "    \"product_code\":\"QUICK_WAP_WAY\"" +
            "  }");//填充业务参数
    String form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
    httpResponse.setContentType("text/html;charset=" + AlipayServiceEnvConstants.CHARSET);
    httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
    httpResponse.getWriter().flush();
}
```

## 下单执行流程

根据接口描述，支付宝下单接口的执行流程如下：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-204.png)

## 支付接口测试

### 编写下单代码  

根据接口流程，首先在订单服务编写测试类请求支付宝下单的接口。

1.在订单服务api工程添加依赖：

```xml
<!-- 支付宝SDK -->
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>3.7.73.ALL</version>
</dependency>

<!-- 支付宝SDK依赖的日志 -->
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>

```

2.AlipayConfig.java到订单服务的service工程

```java
public class AlipayConfig {
    // 商户appid
//	public static String APPID = "";
    // 私钥 pkcs8格式的
//	public static String RSA_PRIVATE_KEY = "";
    // 服务器异步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    public static String notify_url = "http://商户网关地址/alipay.trade.wap.pay-JAVA-UTF-8/notify_url.jsp";
    // 页面跳转同步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 商户可以自定义同步跳转地址
    public static String return_url = "http://商户网关地址/alipay.trade.wap.pay-JAVA-UTF-8/return_url.jsp";
    // 请求网关地址
    public static String URL = "https://openapi.alipaydev.com/gateway.do";
    // 编码
    public static String CHARSET = "UTF-8";
    // 返回格式
    public static String FORMAT = "json";
    // 支付宝公钥
//	public static String ALIPAY_PUBLIC_KEY = "";
    // 日志记录目录
    public static String log_path = "/log";
    // RSA2
    public static String SIGNTYPE = "RSA2";
}
```

3. 在api工程下编写Controller类请求支付宝下单的接口 

```java
@Controller
public class PayTestController {

    @Value("${pay.alipay.APP_ID}")
    private String APP_ID;

    @Value("${pay.alipay.APP_PRIVATE_KEY}")
    private String APP_PRIVATE_KEY;

    @Value("${pay.alipay.ALIPAY_PUBLIC_KEY}")
    private String ALIPAY_PUBLIC_KEY;


    @RequestMapping("/alipaytest")
    public void doPost(HttpServletRequest httpRequest,
                       HttpServletResponse httpResponse) throws ServletException, IOException, AlipayApiException {
        AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);
        //获得初始化的AlipayClient
        AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
//        alipayRequest.setNotifyUrl("http://domain.com/CallBack/notify_url.jsp");//在公共参数中设置回跳和通知地址
        alipayRequest.setBizContent("{" +
                "    \"out_trade_no\":\"202210100010101002\"," +
                "    \"total_amount\":0.1," +
                "    \"subject\":\"Iphone6 16G\"," +
                "    \"product_code\":\"QUICK_WAP_WAY\"" +
                "  }");//填充业务参数
        String form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
        httpResponse.setContentType("text/html;charset=" + AlipayConfig.CHARSET);
        httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
        httpResponse.getWriter().flush();
    }

}
```

4.在nacos中的orders-service-dev.yaml中配置公钥和私钥

```yml
pay:
  alipay:
    APP_ID: 写你自己的AppID
    APP_PRIVATE_KEY: 写你自己的应用私钥
    ALIPAY_PUBLIC_KEY: 写你自己的支付宝公钥
```

注意：应用公钥和支付宝公钥不一样，nacos配置里填`支付宝公钥`

### 生成二维码

用户在前端使用支付宝沙箱通过扫码请求下单接口，我们需要生成订单服务的下单接口的二维码。

ZXing是一个开源的类库，是用Java编写的多格式的1D / 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。



1.在base工程pom.xml中添加依赖：

```xml
<!-- 二维码生成&识别组件 -->
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>core</artifactId>
    <version>3.3.3</version>
</dependency>

<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>javase</artifactId>
    <version>3.3.3</version>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency
```

2.生成二维码方法

参考base工程util包下的QRCodeUtil.java

```java
public static void main(String[] args) throws IOException {
    QRCodeUtil qrCodeUtil = new QRCodeUtil();
    System.out.println(qrCodeUtil.createQRCode("http://www.itcast.cn/", 200, 200));
}
```

### 接口测试

1.生成订单服务下单接口的二维码

 修改我们之前的main方法，将url换成下单接口，注意这里不要用localhost，得用本机局域网ip 

```java
public static void main(String[] args) throws IOException {
      QRCodeUtil qrCodeUtil = new QRCodeUtil();
      System.out.println(qrCodeUtil.createQRCode("http://192.168.101.1:63030/orders/alipaytest", 200, 200));

}
```

  打开模拟器，在模拟器中打开浏览器，将base64串复制到浏览器的地址栏 ，使用截屏工具进行截屏，稍后使用支付宝沙箱客户端扫此图片。

2.启动订单服务

3.打开模拟器，在模拟器中打开支付宝沙箱客户端，并使用沙箱客户端账号密码登录。

## 支付接口查询

支付完成可以调用第三方支付平台的支付结果查询接口 查询支付结果。

文档：https://opendocs.alipay.com/open/02ivbt

示例代码：

```java
AlipayClient alipayClient = new DefaultAlipayClient("https://openapi.alipaydev.com/gateway.do", "app_id", "your private_key", "json", "GBK", "alipay_public_key", "RSA2");
AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
JSONObject bizContent = new JSONObject();
bizContent.put("out_trade_no", "20150320010101001");
//bizContent.put("trade_no", "2014112611001004680073956707");
request.setBizContent(bizContent.toString());
AlipayTradeQueryResponse response = alipayClient.execute(request);
if (response.isSuccess()) {
    System.out.println("调用成功");
} else {
    System.out.println("调用失败");
}
```

刚刚的订单我们已经支付成功，现在可以使用out_trade_on商品订单号或支付宝的交易流水号trade_no去查询支付结果

- out_trade_no：商品订单号，是在下单请求时指定的商品订单号
- trade_no：支付宝交易流水号，是支付完成后，支付宝通知支付结果时发送的trade_no
- 响应结果

```json
{
    "alipay_trade_query_response": {
        "code": "10000",
        "msg": "Success",
        "trade_no": "2013112011001004330000121536",
        "out_trade_no": "6823789339978248",
        "open_id": "2088102122524333",
        "buyer_logon_id": "159****5620",
        "trade_status": "TRADE_CLOSED",
        "total_amount": 88.88,
        "trans_currency": "TWD",
        "settle_currency": "USD",
        "settle_amount": 2.96,
        "pay_currency": 1,
        "pay_amount": "8.88",
        "settle_trans_rate": "30.025",
        "trans_pay_rate": "0.264",
        "alipay_store_id": "2015040900077001000100001232",
        "buyer_pay_amount": 8.88,
        "point_amount": 10,
        "invoice_amount": 12.11,
        "send_pay_date": "2014-11-27 15:45:57",
        "receipt_amount": "15.25",
        "store_id": "NJ_S_001",
        "terminal_id": "NJ_T_001",
        "fund_bill_list": [
            {
                "fund_channel": "ALIPAYACCOUNT",
                "bank_code": "CEB",
                "amount": 10,
                "real_amount": 11.21,
                "fund_type": "DEBIT_CARD"
            }
        ],
        "store_name": "证大五道口店",
        "buyer_user_id": "2088101117955611",
        "discount_goods_detail": "[{\"goods_id\":\"STANDARD1026181538\",\"goods_name\":\"雪碧\",\"discount_amount\":\"100.00\",\"voucher_id\":\"2015102600073002039000002D5O\"}]",
        "industry_sepc_detail": "{\"registration_order_pay\":{\"brlx\":\"1\",\"cblx\":\"1\"}}",
        "industry_sepc_detail_gov": "{\"registration_order_pay\":{\"brlx\":\"1\",\"cblx\":\"1\"}}",
        "industry_sepc_detail_acc": "{\"registration_order_pay\":{\"brlx\":\"1\",\"cblx\":\"1\"}}",
        "voucher_detail_list": [
            {
                "id": "2015102600073002039000002D5O",
                "name": "XX超市5折优惠",
                "type": "ALIPAY_FIX_VOUCHER",
                "amount": 10,
                "merchant_contribute": 9,
                "other_contribute": 1,
                "memo": "学生专用优惠",
                "template_id": "20171030000730015359000EMZP0",
                "other_contribute_detail": [
                    {
                        "contribute_type": "BRAND",
                        "contribute_amount": 8
                    }
                ],
                "purchase_buyer_contribute": 2.01,
                "purchase_merchant_contribute": 1.03,
                "purchase_ant_contribute": 0.82
            }
        ],
        "charge_amount": "8.88",
        "charge_flags": "bluesea_1",
        "settlement_id": "2018101610032004620239146945",
        "trade_settle_info": {
            "trade_settle_detail_list": [
                {
                    "operation_type": "replenish",
                    "operation_serial_no": "2321232323232",
                    "operation_dt": "2019-05-16 09:59:17",
                    "trans_out": "208811****111111",
                    "trans_in": "208811****111111",
                    "amount": 10,
                    "ori_trans_out": "2088111111111111",
                    "ori_trans_in": "2088111111111111"
                }
            ]
        },
        "auth_trade_pay_mode": "CREDIT_PREAUTH_PAY",
        "buyer_user_type": "PRIVATE",
        "mdiscount_amount": "88.88",
        "discount_amount": "88.88",
        "buyer_user_name": "菜鸟网络有限公司",
        "subject": "Iphone6 16G",
        "body": "Iphone6 16G",
        "alipay_sub_merchant_id": "2088301372182171",
        "ext_infos": "{\"action\":\"cancel\"}",
        "passback_params": "merchantBizType%3d3C%26merchantBizNo%3d2016010101111",
        "hb_fq_pay_info": {
            "user_install_num": "3",
            "fq_amount": "10.05"
        },
        "receipt_currency_type": "DC",
        "credit_pay_mode": "creditAdvanceV2",
        "credit_biz_order_id": "ZMCB99202103310000450000041833",
        "enterprise_pay_info": {
            "is_use_enterprise_pay": false,
            "invoice_amount": 80,
            "biz_info": "{\\\"enterprisePayAmount\\\":\\\"0.64\\\"}"
        },
        "hyb_amount": "10.24",
        "bkagent_resp_info": {
            "bindtrx_id": "123412341234",
            "bindclrissr_id": "01",
            "bindpyeracctbk_id": "123123123123",
            "bkpyeruser_code": "123451234512345",
            "estter_location": "+37.28/-121.268"
        },
        "charge_info_list": [
            {
                "charge_fee": 0.01,
                "original_charge_fee": 0.01,
                "switch_fee_rate": "0.03",
                "is_rating_on_trade_receiver": "Y",
                "is_rating_on_switch": "Y",
                "charge_type": "trade",
                "sub_fee_detail_list": [
                    {
                        "charge_fee": 0.1,
                        "original_charge_fee": 0.2,
                        "switch_fee_rate": "0.03"
                    }
                ]
            }
        ]
    },
    "sign": "ERITJKEIJKJHKKKKKKKHJEREEEEEEEEEEE"
}
```

 使用out_trade_no商品订单号去查询，代码如下 

```java
@SpringBootTest
public class AlipayTest {

    @Value("${pay.alipay.APP_ID}")
    private String APP_ID;
    @Value("${pay.alipay.APP_PRIVATE_KEY}")
    private String APP_PRIVATE_KEY;

    @Value("${pay.alipay.ALIPAY_PUBLIC_KEY}")
    private String ALIPAY_PUBLIC_KEY;


    @Test
    public void queryPayResult() throws AlipayApiException {
        AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, "json", AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); //获得初始化的AlipayClient
        AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
        JSONObject bizContent = new JSONObject();
        bizContent.put("out_trade_no", "202210100010101002");
        //bizContent.put("trade_no", "2014112611001004680073956707");
        request.setBizContent(bizContent.toString());
        AlipayTradeQueryResponse response = alipayClient.execute(request);
        if (response.isSuccess()) {
            System.out.println("调用成功");
            String resultJson = response.getBody();
            //转map
            Map resultMap = JSON.parseObject(resultJson, Map.class);
            Map alipay_trade_query_response = (Map) resultMap.get("alipay_trade_query_response");
            //支付结果
            String trade_status = (String) alipay_trade_query_response.get("trade_status");
            System.out.println(trade_status);
        } else {
            System.out.println("调用失败");
        }
    }
}
```

```json
>>>>>>> 控制台输出
调用成功 {
	"msg": "Success",
	"code": "10000",
	"buyer_user_id": "2088722009945224",
	"send_pay_date": "2023-03-18 11:39:51",
	"invoice_amount": "0.00",
	"out_trade_no": "202310100010101002",
	"total_amount": "100000.00",
	"buyer_user_type": "PRIVATE",
	"trade_status": "TRADE_SUCCESS",
	"trade_no": "2023031822001445220502614531",
	"buyer_logon_id": "hex***@sandbox.com",
	"receipt_amount": "0.00",
	"point_amount": "0.00",
	"buyer_pay_amount": "0.00"
}
```

## 支付结果通知接口

### 准备环境

- 对于手机网站支付产生的交易，支付宝会通知商户支付结果，有两种方式
  1. return_url：使用此方式时，不能保证通知到位，所以建议使用notify_url
  2. notify_url

|                          return_url                          |                          notify_url                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 支付成功后点击完成会自动跳转回商家页面地址，同时在URL地址上附带支付结果参数，回跳参数可查看本文前台回跳参数说明。在iOS系统中，唤起支付宝客户端支付完成后，不会自动回到浏览器或商家App。用户可手工切回到浏览器或商家App。 | 异步通知地址，用于接收支付宝推送给商户的支付/退款成功的消息。 |

- 具体的使用方法是在调用下单接口的API中传入异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统
  - 详情参阅：[支付宝异步通知说明](https://opendocs.alipay.com/support/01raw4)
- 根据下单执行流程，订单服务收到支付结果需要对内容进行验签，验签过程如下
  1. 在通知返回参数列表中，出去sign、sign_type两个参数外，凡是通知返回胡来的参数均为待验签的参数。将剩下的参数进行url_decode，然后按照字典排序，组成字符串，得到待签名字符串；生活号异步通知组成的待验签串中须保留sign_type参数
  2. 将签名参数（sigin）使用base64解码为字节码串
  3. 使用RSA的验签方法，通过签名字符串、签名参数（通过base64解码）及支付宝公钥验证签名
  4. 验证签名正确后，必须再严格按照如下描述校验通知数据的正确性
     - 商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。
     - 通过验证out_trade_no、total_amount、appid参数的正确性判断通知请求的合法性。

### 编写测试代码

 1.在下单请求时，设置通知地址request_setNotifyUrl(“商户自己的notify_url地址”) 

```java
@RequestMapping("/alipaytest")
public void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException, AlipayApiException {
    AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);
    //获得初始化的AlipayClient
    AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
    alipayRequest.setNotifyUrl("http://7veh8s.natappfree.cc/orders/paynotify"); //在公共参数中设置回跳和通知地址
    alipayRequest.setBizContent("{" +
            "    \"out_trade_no\":\"202310100011601002\"," +
            "    \"total_amount\":100000," +
            "    \"subject\":\"Iphone6 16G\"," +
            "    \"product_code\":\"QUICK_WAP_WAY\"" +
            "  }");//填充业务参数
    String form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
    httpResponse.setContentType("text/html;charset=" + AlipayConfig.CHARSET);
    httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
    httpResponse.getWriter().flush();
}
```

 由于回调地址必须外网可访问的地址，所以这里需要内网穿透工具 

### 编写通知接口

```java
//接收通知
@PostMapping("/paynotify")
public void paynotify(HttpServletRequest request, HttpServletResponse response) throws IOException, AlipayApiException {
    Map<String, String> params = new HashMap<String, String>();
    Map requestParams = request.getParameterMap();
    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {
        String name = (String) iter.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i]
                    : valueStr + values[i] + ",";
        }
        //乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化
        //valueStr = new String(valueStr.getBytes("ISO-8859-1"), "gbk");
        params.put(name, valueStr);
    }


    //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//
    //计算得出通知验证结果
    //boolean AlipaySignature.rsaCheckV1(Map<String, String> params, String publicKey, String charset, String sign_type)
    boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, "RSA2");

    if (verify_result) {//验证成功
        //////////////////////////////////////////////////////////////////////////////////////////
        //请在这里加上商户的业务逻辑程序代码

        //商户订单号
        String out_trade_no = new String(request.getParameter("out_trade_no").getBytes("ISO-8859-1"), "UTF-8");
        //支付宝交易号

        String trade_no = new String(request.getParameter("trade_no").getBytes("ISO-8859-1"), "UTF-8");

        //交易状态
        String trade_status = new String(request.getParameter("trade_status").getBytes("ISO-8859-1"), "UTF-8");


        //——请根据您的业务逻辑来编写程序（以下代码仅作参考）——

        if (trade_status.equals("TRADE_FINISHED")) {//交易结束
            //判断该笔订单是否在商户网站中已经做过处理
            //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序
            //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的
            //如果有做过处理，不执行商户的业务程序

            //注意：
            //如果签约的是可退款协议，退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知
            //如果没有签约可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。
        } else if (trade_status.equals("TRADE_SUCCESS")) {//交易成功
            System.out.println(trade_status + "交易成功");
            //判断该笔订单是否在商户网站中已经做过处理
            //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序
            //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的
            //如果有做过处理，不执行商户的业务程序

            //注意：
            //如果签约的是可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。
        }
        response.getWriter().write("success");
    } else {
        response.getWriter().write("fail");
    }
}
```

### 通知接口测试

1. 修改订单号，重启订单服务，在接收通知接口上打个断点
2. 配置内网穿透的本地端口为订单服务端口，启动内网穿透客户端
3. 生成二维码，复制base64串到浏览器中打开
4. 打开模拟器、支付宝沙箱，扫码进行字符
5. 观察接受订单数据等是否正常

  

# 生成支付二维码

## 需求分析

> 生成二维码执行流程

打开课程支付引导界面 ，点击“支付宝支付”此时打开支付二维码，用户扫码支付。

首先需要生成支付二维码，用户扫描二维码开始请求支付宝下单，在向支付宝下单前需要添加选课记录、创建商品订单、生成支付交易记录。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-208.png)

1. 前端调用学习中心服务的添加选课接口。

2. 添加选课成功请求订单服务生成支付二维码接口。

3. 生成二维码接口：创建商品订单、生成支付交易记录、生成二维码。

4. 将二维码返回到前端，用户扫码。

> 用户扫码支付流程  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-209.png)

1. 用户输入支付密码，支付成功。

2. 接收第三方平台通知的支付结果。

3. 根据支付结果更新支付交易记录的支付状态为支付成功

> 数据模型

订单支付模式的核心由三张表组成：订单表、订单明细表、支付交易记录表。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-210.png)

订单表：记录订单信息

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-211.png)

订单明细表记录订单的详细信息

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-212.png)

支付交易记录表记录每次支付的交易明细

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-213.png)

> 订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：

1、时间戳+随机数

年月日时分秒毫秒+随机数

2、高并发场景

年月日时分秒毫秒+随机数+redis自增序列

3、订单号中加上业务标识

订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。

4、雪花算法

雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。

本项目订单号生成采用雪花算法。

## 接口定义

在订单服务中定义生成支付二维码接口。

请求：订单信息

```java
@Data
@ToString
public class AddOrderDto  {
    ...
}
```

响应：支付交易记录信息及二维码信息

```java
@Data
@ToString
public class PayRecordDto extends XcPayRecord {

    // 二维码
    private String qrcode;

}
```

接口定义

```java
@Slf4j
@Controller
@Api(value = "订单支付接口", tags = "订单支付接口")
public class OrderController {

    @ApiOperation("生成支付二维码")
    @PostMapping("/generatepaycode")
    @ResponseBody
    public PayRecordDto generatePayCode(@RequestBody AddOrderDto addOrderDto) {

        return null;
    }

}
```

用户扫码请求下单，定义下单接口如下  

```java
@ApiOperation("扫码下单接口")
@GetMapping("/requestpay")
public void requestpay(String payNo, HttpServletResponse httpResponse) throws IOException {

}
```

## 接口开发

### 保存商品订单

定义保存订单信息接口

```java
public interface OrderService {
    /**
     * 创建商品订单
     *
     * @param addOrderDto 订单信息
     */
    PayRecordDto createOrder(String userId, AddOrderDto addOrderDto);
}
```

在保存订单接口中需要完成创建商品订单、创建支付交易记录，接口实现方法如下  

```java
@Service
public class OrderServiceImpl implements OrderService {

    @Resource
    private XcOrdersMapper xcOrdersMapper;

    @Resource
    private XcOrdersGoodsMapper xcOrdersGoodsMapper;

    @Resource
    private XcPayRecordMapper xcPayRecordMapper;

    @Override
    @Transactional
    public PayRecordDto createOrder(String userId, AddOrderDto addOrderDto) {

        //添加商品订单

        //添加支付交易记录

        //生成二维码

        return null;
    }
}
```

​        编写创建商品订单方法，商品订单的数据来源于选课记录，在订单表需要存入选课记录的ID，这里需要作好幂等处理  

```java
@Transactional
public XcOrders saveXcOrders(String userId, AddOrderDto addOrderDto) {

    // 幂等性处理
    XcOrders order = getOrderByBusinessId(addOrderDto.getOutBusinessId());
    if (order != null) {
        return order;
    }
    order = new XcOrders();

    // 生成订单号
    long orderId = IdWorkerUtils.getInstance().nextId();
    order.setId(orderId);
    order.setTotalPrice(addOrderDto.getTotalPrice());
    order.setCreateDate(LocalDateTime.now());
    order.setStatus("600001");//未支付
    order.setUserId(userId);
    order.setOrderType(addOrderDto.getOrderType());
    order.setOrderName(addOrderDto.getOrderName());
    order.setOrderDetail(addOrderDto.getOrderDetail());
    order.setOrderDescrip(addOrderDto.getOrderDescrip());
    order.setOutBusinessId(addOrderDto.getOutBusinessId()); //选课记录id

    int insert = xcOrdersMapper.insert(order);
    if (insert <= 0) {
        BusinessException.cast("添加订单失败");
    }

    // 插入订单明细
    String orderDetailJson = addOrderDto.getOrderDetail();

    List<XcOrdersGoods> xcOrdersGoodsList = JSON.parseArray(orderDetailJson, XcOrdersGoods.class);
    xcOrdersGoodsList.forEach(goods->{
        // 遍历插入订单明细表
        XcOrdersGoods xcOrdersGoods = new XcOrdersGoods();
        BeanUtils.copyProperties(goods,xcOrdersGoods);
        xcOrdersGoods.setOrderId(orderId);//订单号
        xcOrdersGoodsMapper.insert(xcOrdersGoods);
    });
    return order;
}

public XcOrders getOrderByBusinessId(String businessId) {
    XcOrders orders = xcOrdersMapper.selectOne(new LambdaQueryWrapper<XcOrders>().eq(XcOrders::getOutBusinessId, businessId));
    return orders;
}
```

### 创建支付交易记录

在请求微信或支付宝下单接口时需要传入 商品订单号，在与第三方支付平台对接时发现，当用户支付失败或因为其它原因最终该订单没有支付成功，此时再次调用第三方支付平台的下单接口发现报错“订单号已存在”，此时如果我们传入一个没有使用过的订单号就可以解决问题，**但是商品订单已经创建，因为没有支付成功重新创建一个新订单是不合理的。**

解决以上问题的方案是：

1、用户每次发起都创建一个新的支付交易记录 ，此交易记录与商品订单关联。

2、将支付交易记录的流水号传给第三方支付系统下单接口，这样就即使没有支付成功就不会出现上边的问题。

3、需要提醒用户不要重复支付。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-214.png)

​        编写创建支付交易记录的方法  

```java
public XcPayRecord createPayRecord(XcOrders orders){

    // 订单id
    Long ordersId = orders.getId();
    XcOrders xcOrders = xcOrdersMapper.selectById(ordersId);

    // 如果此订单不存在，不能添加支付记录
    if (xcOrders == null) {
        BusinessException.cast("订单不存在");
    }

    // 订单状态
    String status = xcOrders.getStatus();
    // 如果此订单支付成功，不再添加支付记录，避免重复支付
    if ("601002".equals(status)) {
        BusinessException.cast("此订单已支付");
    }
    // 添加支付记录
    XcPayRecord payRecord = new XcPayRecord();

    // 支付记录号，用于传给支付宝
    payRecord.setPayNo(IdWorkerUtils.getInstance().nextId());
    payRecord.setOrderId(orders.getId()); // 商品订单号
    payRecord.setOrderName(orders.getOrderName());
    payRecord.setTotalPrice(orders.getTotalPrice());
    payRecord.setCurrency("CNY");
    payRecord.setCreateDate(LocalDateTime.now());
    payRecord.setStatus("601001"); //未支付
    payRecord.setUserId(orders.getUserId());

    int insert = xcPayRecordMapper.insert(payRecord);
    if (insert <= 0) {
        BusinessException.cast("插入支付记录失败");
    }

    return payRecord;

}
```

### 生成支付二维码

1.在nacos中orders-service-dev.yaml配置二维码的url  

```java
pay:
 qrcodeurl: http://192.168.56.1/api/orders/requestpay?payNo=%s
```

2.完善创建订单service方法:

```java
@Override
@Transactional
public PayRecordDto createOrder(String userId, AddOrderDto addOrderDto) {

    //添加商品订单
    XcOrders xcOrders = saveXcOrders(userId, addOrderDto);
    //添加支付交易记录
    XcPayRecord payRecord = createPayRecord(xcOrders);
    Long payNo = payRecord.getPayNo();

    //生成二维码
    QRCodeUtil qrCodeUtil = new QRCodeUtil();
    // 支付二维码的url
    String url = String.format(qrcodeurl, payNo);
    // 二维码图片
    String qrCode = null;
    try {
        qrCode = qrCodeUtil.createQRCode(url, 200, 200);
    } catch (IOException e) {
        BusinessException.cast("生成二维码出现异常");
    }

    PayRecordDto payRecordDto = new PayRecordDto();
    BeanUtils.copyProperties(payRecord, payRecordDto);
    payRecordDto.setQrcode(qrCode);

    return payRecordDto;
}
```

### 生成二维码接口完善

```java
@Slf4j
@Controller
@Api(value = "订单支付接口", tags = "订单支付接口")
public class OrderController {

@Resource
private OrderService orderService; 

@ApiOperation("生成支付二维码")
@PostMapping("/generatepaycode")
@ResponseBody
public PayRecordDto generatePayCode(@RequestBody AddOrderDto addOrderDto) {
    //登录用户
    SecurityUtil.XcUser user = SecurityUtil.getUser();
    if(user == null){
        BusinessException.cast("请登录后继续选课");
    }
    return orderService.createOrder(user.getId(), addOrderDto);

}
```

### 扫码下单接口完善

生成了支付二维码，用户扫码请求第三方支付平台下单、支付。

1、定义查询支付交易记录的Service接口与实现方法

```java
/**
 * 查询支付交易记录
 *
 * @param payNo 交易记录号
 */
XcPayRecord getPayRecordByPayno(String payNo);
```

```java
@Override
public XcPayRecord getPayRecordByPayno(String payNo) {
    return xcPayRecordMapper.selectOne(
            new LambdaQueryWrapper<XcPayRecord>()
                    .eq(XcPayRecord::getPayNo, payNo));
}
```

2、定义下单接口如下  

```java
@ApiOperation("扫码下单接口")
@GetMapping("/requestpay")
public void requestpay(String payNo, HttpServletResponse httpResponse) throws IOException {

    // 如果payNo不存在则提示重新发起支付
    XcPayRecord payRecord = orderService.getPayRecordByPayno(payNo);
    if(payRecord == null){
        BusinessException.cast("请重新点击支付获取二维码");
    }

    // 支付状态
    String status = payRecord.getStatus();
    if("601002".equals(status)){
        BusinessException.cast("订单已支付，请勿重复支付。");
    }

    // 构造sdk的客户端对象
    AlipayClient client = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);//获得初始化的AlipayClient
    AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
//        alipayRequest.setNotifyUrl("http://tjxt-user-t.itheima.net/xuecheng/orders/paynotify");//在公共参数中设置回跳和通知地址
    alipayRequest.setBizContent("{" +
            " \"out_trade_no\":\""+payRecord.getPayNo()+"\"," +
            " \"total_amount\":\""+payRecord.getTotalPrice()+"\"," +
            " \"subject\":\""+payRecord.getOrderName()+"\"," +
            " \"product_code\":\"QUICK_WAP_PAY\"" +
            " }");//填充业务参数
    String form = "";
    try {
        //请求支付宝下单接口,发起http请求
        form = client.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
    } catch (AlipayApiException e) {
        e.printStackTrace();
    }
    httpResponse.setContentType("text/html;charset=" + AlipayConfig.CHARSET);
    httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
    httpResponse.getWriter().flush();
    httpResponse.getWriter().close();

}
```

## 支付测试

1. 重启所有服务
2. 发布一门收费课程
3. 进入收费课程详情页面，点击马上学习，点击支付宝支付，生成二维码
4. 将二维码保存，使用沙盒环境支付宝扫码支付，测试是否正常
5. 打断点观察订单是否创建成功，支付交易记录是否创建成功，在数据库中验证

# 查询支付结果

## 接口定义

根据前边我们调研的获取支付结果的接口，包括：主动查询支付结果、被动接收支付结果。

这里先实现主动查询支付结果，当支付完成用户点击“支付结果”将请求第三方支付平台查询支付结果。

在OrderController类中定义接口如下：

```java
@ApiOperation("查询支付结果")
@GetMapping("/payresult")
@ResponseBody
public PayRecordDto payresult(String payNo) throws IOException {

    //查询支付结果
    
    return null;

}
```

## 接口实现

1、定义查询支付结果的service

```java
/**
 * 请求支付宝查询支付结果
 *
 * @param payNo 支付记录id
 * @return 支付记录信息
 */
PayRecordDto queryPayResult(String payNo);
```

2、service实现如下：

```java
@Override
public PayRecordDto queryPayResult(String payNo) {

    XcPayRecord payRecord = getPayRecordByPayno(payNo);
    if (payRecord == null) {
        BusinessException.cast("请重新点击支付获取二维码");
    }
    // 支付状态
    String status = payRecord.getStatus();

    // 如果支付成功直接返回
    if ("601002".equals(status)) {
        PayRecordDto payRecordDto = new PayRecordDto();
        BeanUtils.copyProperties(payRecord, payRecordDto);
        return payRecordDto;
    }

    // 调用支付宝的接口查询支付宝结果
    PayStatusDto payStatusDto = queryPayResultFromAlipay(payNo);
    log.info("payStatusDto: {}", payStatusDto);
    // 获取支付结果更新支付记录表和订单表的支付状态
    saveAliPayStatus(payStatusDto);
    // 重新查询支付记录
    payRecord = getPayRecordByPayno(payNo);
    PayRecordDto payRecordDto = new PayRecordDto();
    BeanUtils.copyProperties(payRecord, payRecordDto);

    return payRecordDto;
}
```

```java
/**
 * 请求支付宝查询支付结果
 * @param payNo 支付交易号
 * @return 支付结果
 */
public PayStatusDto queryPayResultFromAlipay(String payNo){

}

/**
 * @description 保存支付宝支付结果
 * @param payStatusDto  支付结果信息
 * @return void
 * @author Mr.M
 * @date 2022/10/4 16:52
 */
public void saveAliPayStatus(PayStatusDto payStatusDto) {

}
```

### 查询支付结果

```java
public PayStatusDto queryPayResultFromAlipay(String payNo) {
    //========请求支付宝查询支付结果=============
    AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, "json", AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); //获得初始化的AlipayClient
    AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
    JSONObject bizContent = new JSONObject();
    bizContent.put("out_trade_no", payNo);
    request.setBizContent(bizContent.toString());
    AlipayTradeQueryResponse response = null;
    try {
        response = alipayClient.execute(request);
        if (!response.isSuccess()) {
            BusinessException.cast("请求支付查询查询失败");
        }
    } catch (AlipayApiException e) {
        log.error("请求支付宝查询支付结果异常:{}", e.toString(), e);
        BusinessException.cast("请求支付查询查询失败");
    }

    // 获取支付结果
    String resultJson = response.getBody();
    // 转map
    Map resultMap = JSON.parseObject(resultJson, Map.class);
    Map alipay_trade_query_response = (Map) resultMap.get("alipay_trade_query_response");
    // 支付结果
    String trade_status = (String) alipay_trade_query_response.get("trade_status");
    String total_amount = (String) alipay_trade_query_response.get("total_amount");
    String trade_no = (String) alipay_trade_query_response.get("trade_no");
    // 保存支付结果
    PayStatusDto payStatusDto = new PayStatusDto();
    payStatusDto.setOut_trade_no(payNo);
    payStatusDto.setTrade_status(trade_status);
    payStatusDto.setApp_id(APP_ID);
    payStatusDto.setTrade_no(trade_no);
    payStatusDto.setTotal_amount(total_amount);

    return payStatusDto;
}
```

### 保存支付结果

```java
/**
 * 保存支付宝支付结果
 *
 * @param payStatusDto 支付结果信息
 */
void saveAliPayStatus(PayStatusDto payStatusDto);
```

```java
@Override
@Transactional
public void saveAliPayStatus(PayStatusDto payStatusDto) {
    // 支付流水号
    String payNo = payStatusDto.getOut_trade_no();
    XcPayRecord payRecord = getPayRecordByPayno(payNo);
    if (payRecord == null) {
        BusinessException.cast("支付记录找不到");
    }
    // 支付结果
    String trade_status = payStatusDto.getTrade_status();
    log.debug("收到支付结果:{},支付记录:{}}", payStatusDto.toString(), payRecord.toString());
    if (trade_status.equals("TRADE_SUCCESS")) {

        // 支付金额变为分
        Float totalPrice = payRecord.getTotalPrice() * 100;
        Float total_amount = Float.parseFloat(payStatusDto.getTotal_amount()) * 100;
        // 校验是否一致
        if (!payStatusDto.getApp_id().equals(APP_ID) || totalPrice.intValue() != total_amount.intValue()) {
            // 校验失败
            log.info("校验支付结果失败,支付记录:{},APP_ID:{},totalPrice:{}", payRecord.toString(), payStatusDto.getApp_id(), total_amount.intValue());
            BusinessException.cast("校验支付结果失败");
        }
        log.debug("更新支付结果,支付交易流水号:{},支付结果:{}", payNo, trade_status);
        XcPayRecord payRecord_u = new XcPayRecord();
        payRecord_u.setStatus("601002");//支付成功
        payRecord_u.setOutPayChannel("Alipay");
        payRecord_u.setOutPayNo(payStatusDto.getTrade_no());//支付宝交易号
        payRecord_u.setPaySuccessTime(LocalDateTime.now());//通知时间
        int update1 = xcPayRecordMapper.update(payRecord_u, new LambdaQueryWrapper<XcPayRecord>().eq(XcPayRecord::getPayNo, payNo));
        if (update1 > 0) {
            log.info("更新支付记录状态成功:{}", payRecord_u.toString());
        } else {
            log.info("更新支付记录状态失败:{}", payRecord_u.toString());
            BusinessException.cast("更新支付记录状态失败");
        }
        //关联的订单号
        Long orderId = payRecord.getOrderId();
        XcOrders orders = xcOrdersMapper.selectById(orderId);
        if (orders == null) {
            log.info("根据支付记录[{}}]找不到订单", payRecord_u.toString());
            BusinessException.cast("根据支付记录找不到订单");
        }
        XcOrders order_u = new XcOrders();
        order_u.setStatus("600002");//支付成功
        int update = xcOrdersMapper.update(order_u, new LambdaQueryWrapper<XcOrders>().eq(XcOrders::getId, orderId));
        if (update > 0) {
            log.info("更新订单表状态成功,订单号:{}", orderId);
        } else {
            log.info("更新订单表状态失败,订单号:{}", orderId);
            BusinessException.cast("更新订单表状态失败");
        }
    }

}
```

## 接口测试

> 完善接口

```java
@ApiOperation("查询支付结果")
@GetMapping("/payresult")
@ResponseBody
public PayRecordDto payresult(String payNo) throws IOException {

    return orderService.queryPayResult(payNo);

}
```

> 测试流程

完成生成支付二维码，用支付宝扫码但不支付，使用httpclient请求查询支付结果，查询失败

```json
### 查询支付结果
GET {{orders_host}}/orders/payresult?payNo=1628648111951941632
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJ7XCJiaXJ0aGRheVwiOlwiMjAyMi0wOS0yOFQxOToyODo0NlwiLFwiY3JlYXRlVGltZVwiOlwiMjAyMi0wOS0yOFQwODozMjowM1wiLFwiaWRcIjpcIjUwXCIsXCJuYW1lXCI6XCLlrabnlJ8xXCIsXCJuaWNrbmFtZVwiOlwi5aSn5rC054mbXCIsXCJwZXJtaXNzaW9uc1wiOltdLFwic2V4XCI6XCIxXCIsXCJzdGF0dXNcIjpcIjFcIixcInVzZXJuYW1lXCI6XCJzdHUxXCIsXCJ1c2VycGljXCI6XCJodHRwOi8vZmlsZS41MXh1ZWNoZW5nLmNuL2RkZGZcIixcInV0eXBlXCI6XCIxMDEwMDFcIn0iLCJzY29wZSI6WyJhbGwiXSwiZXhwIjoxNjc3MTQwMDI1LCJhdXRob3JpdGllcyI6WyJwMSJdLCJqdGkiOiJmYThiMmY1OS03ZTQ5LTRmODUtOTBlMC05NzYwNjlkYjE3ODIiLCJjbGllbnRfaWQiOiJYY1dlYkFwcCJ9.89sp5lPdFafZ_HdGhe8Cpv0anMJC3vT4PtaGMHgCkr8
```

用支付宝扫码再次完成支付

使用httpclient请求查询支付结果，支付结果为成功，并更新支付记录状态和订单状态。

> 使用前后端联调  

# 接收支付通知

## 接口定义

支付完成后第三方支付系统会主动通知支付结果，要实现主动通知需要在请求支付系统下单时传入NotifyUrl，这里有两个url：NotifyUrl和ReturnUrl，ReturnUrl是支付完成后支付系统携带支付结果重定向到ReturnUrl地址，NotifyUrl是支付完成后支付系统在后台定时去通知，使用NotifyUrl比使用ReturnUrl有保证。

根据接口描述：https://opendocs.alipay.com/open/203/105286的内容下边在订单服务定义接收支付结果通知的接口。

首先在下单时指定NotifyUrl:

```java
alipayRequest.setNotifyUrl("http://tjxt-user-t.itheima.net/xuecheng/orders/receivenotify");
```

```java
@PostMapping("/paynotify")
public void paynotify(HttpServletRequest request, HttpServletResponse response) throws IOException, AlipayApiException {
    Map<String, String> params = new HashMap<>();
    Map requestParams = request.getParameterMap();
    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {
        String name = (String) iter.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i]
                    : valueStr + values[i] + ",";
        }
        params.put(name, valueStr);
    }
    boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, "RSA2");

    if (verify_result) {
        //商户订单号
        String out_trade_no = new String(request.getParameter("out_trade_no").getBytes("ISO-8859-1"), "UTF-8");
        //支付宝交易号
        String trade_no = new String(request.getParameter("trade_no").getBytes("ISO-8859-1"), "UTF-8");
        //交易状态
        String trade_status = new String(request.getParameter("trade_status").getBytes("ISO-8859-1"), "UTF-8");
        //付款金额
        String total_amount = new String(request.getParameter("total_amount").getBytes("ISO-8859-1"), "UTF-8");
        if (trade_status.equals("TRADE_FINISHED")) {//交易结束

        } else if (trade_status.equals("TRADE_SUCCESS")) {
            // 交易成功，保存订单信息
            PayStatusDto payStatusDto = new PayStatusDto();
            payStatusDto.setOut_trade_no(out_trade_no);
            payStatusDto.setTrade_no(trade_no);
            payStatusDto.setApp_id(APP_ID);
            payStatusDto.setTrade_status(trade_status);
            payStatusDto.setTotal_amount(total_amount);
            orderService.saveAlipayStatus(payStatusDto);
            log.debug("交易成功");
        }
        response.getWriter().write("success");
    } else {
        response.getWriter().write("fail");
    }
}
```

- 重启服务，打断点测试
- 当我们支付完成后，数据库中的订单状态为已完成，并且再次点击`支付宝支付`时，会提示订单已支付

