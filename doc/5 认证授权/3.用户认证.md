# 需求分析

实现用户认证功能

# 连接用户中心数据库

## 连接数据库认证

基于的认证流程在研究Spring Security过程中已经测试通过，到目前为止用户认证流程如下：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-154.png)

认证所需要的用户信息存储在用户中心数据库，现在需要将认证服务连接数据库查询用户信息。

在研究Spring Security的过程中是将用户信息硬编码  

```java
@Bean
public UserDetailsService userDetailsService() {
    //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
    manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
    return manager;
}
```

> SpringSecurity工作原理图

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-141.png)

用户提交账号和密码由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息  

查询DaoAuthenticationProvider的源代码如下：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-155.png)

UserDetailsService是一个接口  

```java
package org.springframework.security.core.userdetails;

public interface UserDetailsService {
    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
}
```

UserDetails是用户信息接口

```java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```

只要实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可，框架调用loadUserByUsername()方法拿到用户信息之后是如何执行的  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-156.png)

 屏蔽原来定义的UserDetailsService。  

```java
// 配置用户信息服务
//    @Bean
//    public UserDetailsService userDetailsService() {
//        // 这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
//        manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
//        manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
//        return manager;
//    }
```

自定义UserDetailsService

```java
@Component
public class UserServiceImpl implements UserDetailsService {

    @Resource
    private XcUserMapper xcUserMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 根据username查询数据库
        XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));

        // 查询用户不存在，返回NULL，SpringSecurity框架抛出异常用户不存在
        if (xcUser == null) {
            return null;
        }
        // 查询用户存在，拿到正确密码，最终封装成UserDetails对象给SpringSecurity框架返回，由框架进行密码对比
        String password = xcUser.getPassword();

        // 权限
        String[] authorities = {"test"};
        UserDetails userDetails = User.withUsername(username).password(password).authorities(authorities).build();

        return userDetails;
    }
}
```

数据库中的密码加过密的，用户输入的密码是明文，我们需要修改密码格式器PasswordEncoder，原来使用的是NoOpPasswordEncoder，它是通过明文方式比较密码，现在我们修改为BCryptPasswordEncoder，它是将用户输入的密码编码为BCrypt格式与数据库中的密码进行比对。

```java
@Bean
public PasswordEncoder passwordEncoder() {
    // 密码为明文方式
//        return NoOpPasswordEncoder.getInstance();
    return new BCryptPasswordEncoder();
}
```

修改数据库中的密码为Bcrypt格式，并且记录明文密码，稍后申请令牌时需要。

由于修改密码编码方式还需要将客户端的密钥更改为Bcrypt格式.

```java
// 客户端详情服务
@Override
public void configure(ClientDetailsServiceConfigurer clients)
        throws Exception {
    clients.inMemory()// 使用in-memory存储
            .withClient("XcWebApp")// client_id
//                .secret("XcWebApp")//客户端密钥
            .secret(new BCryptPasswordEncoder().encode("XcWebApp"))//客户端密钥
            .resourceIds("xuecheng-plus")//资源列表
            .authorizedGrantTypes("authorization_code", "password", "client_credentials", "implicit", "refresh_token")// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials
            .scopes("all")// 允许的授权范围
            .autoApprove(false)//false跳转到授权页面
            //客户端接收授权码的重定向地址
            .redirectUris("http://www.51xuecheng.cn")
    ;
}
```

重启认证服务，使用httpclient进行测试

```json
### 密码模式
POST {{auth_host}}/auth/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username=stu1&password=111111
```

输入正确的账号和密码，申请令牌成功。

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJzdHUxIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTY4ODcxMjE1NiwiYXV0aG9yaXRpZXMiOlsidGVzdCJdLCJqdGkiOiI1NDUyM2I5NS1hMzhhLTRiYWYtOWQzOC05OTgxZDljMWFiY2QiLCJjbGllbnRfaWQiOiJYY1dlYkFwcCJ9.THg-fzP5jeB14191QBwTVuM5Ic3BR2CvNU60fTyIqqY",
  "token_type": "bearer",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJzdHUxIiwic2NvcGUiOlsiYWxsIl0sImF0aSI6IjU0NTIzYjk1LWEzOGEtNGJhZi05ZDM4LTk5ODFkOWMxYWJjZCIsImV4cCI6MTY4ODk2NDE1NiwiYXV0aG9yaXRpZXMiOlsidGVzdCJdLCJqdGkiOiJiN2UwZjAwMy1hODY0LTRlODUtYmFkZS1jNTBlOTEwNDk4YzIiLCJjbGllbnRfaWQiOiJYY1dlYkFwcCJ9.-nxhtscfR6jr9sJlShzCX45HVGE3gUyCLSrivKC3wTE",
  "expires_in": 7199,
  "scope": "all",
  "jti": "54523b95-a38a-4baf-9d38-9981d9c1abcd"
}
```

输入错误的密码，报错：

```json
{
  "error": "invalid_grant",
  "error_description": "用户名或密码错误"
}
```

输入错误的账号，报错：

```json
{
  "error": "unauthorized",
  "error_description": "UserDetailsService returned null, which is an interface contract violation"
}
```

## 扩展用户身份信息

用户表中存储了用户的账号、手机号、email，昵称、qq等信息，UserDetails接口只返回了username、密码等信息  

```java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```

需要扩展用户身份的信息，在jwt令牌中存储用户的昵称、头像、qq等信息。

在认证阶段DaoAuthenticationProvider会调用UserDetailService查询用户的信息，这里是可以获取到齐全的用户信息的。

由于JWT令牌中用户身份信息来源于UserDetails，UserDetails中仅定义了username为用户的身份信息，

* 第一是可以扩展UserDetails，使之包括更多的自定义属性
* 第二也可以扩展username的内容 ，比如存入json数据内容作为username的内容。相比较而言，方案二比较简单还不用破坏UserDetails的结构，我们采用方案二。

```java
@Component
public class UserServiceImpl implements UserDetailsService {

    @Resource
    private XcUserMapper xcUserMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 根据username查询数据库
        XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));

        // 查询用户不存在，返回NULL，SpringSecurity框架抛出异常用户不存在
        if (xcUser == null) {
            return null;
        }
        // 查询用户存在，拿到正确密码，最终封装成UserDetails对象给SpringSecurity框架返回，由框架进行密码对比
        String password = xcUser.getPassword();

        // 权限
        String[] authorities = {"test"};
        xcUser.setPassword(null);
        String userJson = JSON.toJSONString(xcUser);
        UserDetails userDetails = User.withUsername(userJson).password(password).authorities(authorities).build();

        return userDetails;
    }
} 
```

重启认证服务，重新生成令牌，生成成功。

我们可以使用check_token查询jwt的内容

user_name存储了用户信息的json格式，在资源服务中就可以取出该json格式的内容转为用户对象去使用。

## 资源服务获取用户身份

> 在content-api中定义类：获取当前登录用户的对象  

```java
public class SecurityUtil {

    public static XcUser getUser() {
        try {
            // 获取当前用户身份
            Object principalObj = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            if (principalObj instanceof String) {
                // 取出用户身份信息
                String principal = principalObj.toString();
                // 将json转成对象
                XcUser user = JSON.parseObject(principal, XcUser.class);
                return user;
            }
        } catch (Exception e) {
            log.error("获取当前登录用户身份出错:{}", e.getMessage());
            e.printStackTrace();
        }

        return null;
    }

    @Data
    public static class XcUser implements Serializable {

        private static final long serialVersionUID = 1L;

        private String id;

        private String username;

        private String password;

        private String salt;

        private String name;
        private String nickname;
        private String wxUnionid;
        private String companyId;
        /**
         * 头像
         */
        private String userpic;

        private String utype;

        private LocalDateTime birthday;

        private String sex;

        private String email;

        private String cellphone;

        private String qq;

        /**
         * 用户状态
         */
        private String status;

        private LocalDateTime createTime;

        private LocalDateTime updateTime;

    }

}
```

 在内容管理服务中测试此工具类，以查询课程信息接口为例  

```java
@ApiOperation("根据id查询课程信息接口")
@GetMapping("/course/{courseId}")
public CourseBaseInfoDto getCourseBaseById(@PathVariable Long courseId) {
//        // 获取当前用户身份
//        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
//        System.out.println(">>>>>>>>>>>>>>>>>>>principal=: " + principal);
    SecurityUtil.XcUser user = SecurityUtil.getUser();
    System.out.println(">>>>>>>>>>>>>>>>>> username: " + user.getUsername());
    return courseBaseService.getCourseBaseInfo(courseId);
}
```

重启内容管理服务：

1、启动认证服务、网关、内容管理服务

2、生成新的令牌

3、携带令牌访问内容管理服务的查询课程接口

# 支持多样化方式认证

## 统一认证入口

目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。基于当前研究的Spring Security认证流程如何支持多样化的认证方式呢  

支持账号和密码认证：采用OAuth2协议的密码模式即可实现。

支持手机号加验证码认证：用户认证提交的是手机号和验证码，并不是账号和密码。

微信扫码认证：基于OAuth2协议与微信交互，学成在线网站向微信服务器申请到一个令牌，然后携带令牌去微信查询用户信息，查询成功则用户在学成在线项目认证通过。

在loadUserByUsername()方法上，将用户原来提交的账号数据改为提交json数据，json数据可以扩展不同认证方式所提交的各种参数。 

> 创建一个DTO类表示认证的参数  

```java
@Data
public class AuthParamsDto {

    private String username; // 用户名
    private String password; // 域  用于扩展
    private String cellphone; // 手机号
    private String checkcode; // 验证码
    private String checkcodekey; // 验证码key
    private String authType; // 认证的类型   password:用户名密码模式类型    sms:短信模式类型
    private Map<String, Object> payload = new HashMap<>(); // 附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId
}
```

> 此时loadUserByUsername()方法可以修改如下：

```java
@Override
public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
    // 将传入的Json数据转换成对象
    AuthParamsDto authParamsDto = null;

    try {
        authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
    } catch (Exception e) {
       throw new RuntimeException("请求认证参数不符合要求");
    }

    String username = authParamsDto.getUsername();
    // 根据username查询数据库
    XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));

    // 查询用户不存在，返回NULL，SpringSecurity框架抛出异常用户不存在
    if (xcUser == null) {
        return null;
    }
    // 查询用户存在，拿到正确密码，最终封装成UserDetails对象给SpringSecurity框架返回，由框架进行密码对比
    String password = xcUser.getPassword();

    // 权限
    String[] authorities = {"test"};
    xcUser.setPassword(null);
    String userJson = JSON.toJSONString(xcUser);
    UserDetails userDetails = User.withUsername(userJson).password(password).authorities(authorities).build();

    return userDetails;
}
```

**原来的DaoAuthenticationProvider 会进行密码校验**，现在重新定义DaoAuthenticationProviderCustom类，重写类的additionalAuthenticationChecks方法。

```java
/**
 * 统一了认证入口， 重写DaoAuthenticationProvider方法，有些认证方式不需要校验密码
 *
 * @author Cyan Chau
 * @create 2023-07-07
 */
@Component
public class DaoAuthenticationProviderCustom extends DaoAuthenticationProvider {

    @Resource
    public void setUserDetailsService(UserDetailsService userDetailsService) {
        super.setUserDetailsService(userDetailsService);
    }

    // 屏蔽密码对比
    @Override
    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        super.additionalAuthenticationChecks(userDetails, authentication);
    }
}
```

修改WebSecurityConfig类指定daoAuthenticationProviderCustom

```java
@Resource
private DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.authenticationProvider(daoAuthenticationProviderCustom);
}
```

此时可以重启认证服务，测试申请令牌接口，传入的账号信息改为json数据  

```json
###密码模式
POST {{auth_host}}/auth/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username={"username":"stu1","authType":"password","password":"111111"}
```

经过测试发现loadUserByUsername()方法可以正常接收到认证请求中的json数据。

有了这些认证参数我们可以定义一个认证Service接口去进行各种方式的认证。

定义用户信息，为了扩展性让它继承XcUser

```java
@Data
public class XcUserExt extends XcUser {
    // 用户权限
    List<String> permissions = new ArrayList<>();
}
```

定义认证Service 接口

```java
public interface AuthService {

    /**
     * 认证方法
     *
     * @param authParamsDto 认证参数
     */
    XcUserExt execute(AuthParamsDto authParamsDto);
}
```

 loadUserByUsername()修改如下：  

```java
@Override
public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
    // 将传入的Json数据转换成对象
    AuthParamsDto authParamsDto = null;

    try {
        authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
    } catch (Exception e) {
       throw new RuntimeException("请求认证参数不符合要求");
    }

    // 认证类型
    String authType = authParamsDto.getAuthType();
    // 根据认证类型从Spring容器中取出指定的Bean
    String beanName = authType + "AuthService";
    AuthService authService = applicationContext.getBean(beanName, AuthService.class);
    // 调用统一认证
    XcUserExt execute = authService.execute(authParamsDto);


    String username = authParamsDto.getUsername();
    // 根据username查询数据库
    XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));

    // 查询用户不存在，返回NULL，SpringSecurity框架抛出异常用户不存在
    if (xcUser == null) {
        return null;
    }
    // 查询用户存在，拿到正确密码，最终封装成UserDetails对象给SpringSecurity框架返回，由框架进行密码对比
    String password = xcUser.getPassword();

    // 权限
    String[] authorities = {"test"};
    xcUser.setPassword(null);
    String userJson = JSON.toJSONString(xcUser);
    UserDetails userDetails = User.withUsername(userJson).password(password).authorities(authorities).build();

    return userDetails;
}
```

基于Spring Security认证流程修改为如下  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-157.png)

## 实现账号密码认证

```java
@Service("passwordAuthService")
public class PasswordAuthServiceImpl implements AuthService {

    @Resource
    private XcUserMapper xcUserMapper;

    @Resource
    private PasswordEncoder passwordEncoder;

    @Override
    public XcUserExt execute(AuthParamsDto authParamsDto) {

        // 账号
        String username = authParamsDto.getUsername();

        // TODO 校验验证码

        // *********账户是否存在
        XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));
        if (xcUser == null) {
            throw new RuntimeException("账户不存在");
        }

        // ***********验证密码是否正确
        // 如果用户存在，获取数据库中的密码
        String passwordFromDb = xcUser.getPassword();
        // 获取用户输入的密码
        String passwordFromWeb = authParamsDto.getPassword();
        // 校验密码
        boolean matches = passwordEncoder.matches(passwordFromWeb, passwordFromDb);
        if (!matches) {
            throw new RuntimeException("账户或密码错误");
        }

        XcUserExt xcUserExt = new XcUserExt();
        BeanUtils.copyProperties(xcUser, xcUserExt);

        return xcUserExt;
    }
}
```

修改UserServiceImpl类，根据认证方式使用不同的认证bean

```java
@Slf4j
@Component
public class UserServiceImpl implements UserDetailsService {

    @Resource
    private XcUserMapper xcUserMapper;

    @Resource
    private ApplicationContext applicationContext;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 将传入的Json数据转换成对象
        AuthParamsDto authParamsDto = null;

        try {
            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
        } catch (Exception e) {
            log.info("认证请求参数不符合要求：{}", s);
           throw new RuntimeException("认证请求参数不符合要求");
        }

        // 认证类型
        String authType = authParamsDto.getAuthType();
        // 根据认证类型从Spring容器中取出指定的Bean
        String beanName = authType + "AuthService";
        AuthService authService = applicationContext.getBean(beanName, AuthService.class);
        // 调用统一认证
        XcUserExt xcUserExt = authService.execute(authParamsDto);

        return getUserPrincipal(xcUserExt);
    }

    /**
     * 查询用户信息
     *
     * @param user 用户主键
     * @return
     */
    public UserDetails getUserPrincipal(XcUserExt user) {

        String password = user.getPassword();
        // 权限
        String[] authorities = {"p1"};
        user.setPassword(null);
        String userJson = JSON.toJSONString(user);
        UserDetails userDetails = User.withUsername(userJson).password(password).authorities(authorities).build();

        return userDetails;
    }
}
```

重启认证服务，测试申请令牌接口。
1、测试账号和密码都正确的情况是否可以申请令牌成功。
2、测试密码错误的情况。
3、测试账号不存在情况。

