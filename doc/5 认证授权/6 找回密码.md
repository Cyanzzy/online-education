# 需求分析

忘记密码需要找回，可以通过手机号找回密码，通过邮箱找回密码以及人工通道。

界面访问地址：http://www.51xuecheng.cn/findpassword.html  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-179.png)

> 接口：

```json
手机验证码：/api/checkcode/phone?param1=手机号

邮箱验证码：/api/checkcode/phone?param1=电子邮箱地址

找回密码：/api/auth/findpassword
```

> 请求

```json
{
     cellphone:'',
     email:'',
     checkcodekey:'',
     checkcode:'',
     confirmpwd:'',
     password:''
 }
```

> 响应

```json
200: 找回成功

其它：找回失败，失败原因使用统一异常处理返回的信息格式
```

> 执行流程

1、校验验证码，不一致则抛出异常

2、判断两次密码是否一致，不一致则抛出异常

3、根据手机号和邮箱查询用户

4、如果找到用户更新为新密码

# 接口开发

> 在checkcode模块中导入邮件发送相关依赖 

```xml
<!-- https://mvnrepository.com/artifact/javax.activation/activation -->
<dependency>
    <groupId>javax.activation</groupId>
    <artifactId>activation</artifactId>
    <version>1.1.1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/javax.mail/mail -->
<dependency>
    <groupId>javax.mail</groupId>
    <artifactId>mail</artifactId>
    <version>1.4.7</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-email</artifactId>
    <version>1.4</version>
</dependency>
```

> 接口设计

```java
@ApiOperation(value = "发送邮箱验证码", tags = "发送邮箱验证码")
@PostMapping("/checkcode/phone")
public void sendEMail(@RequestParam("param1") String email) {

}
```

```java
@RestController
@RequestMapping("/auth")
public class AuthFindPwController {

    @ApiOperation(value = "找回密码", tags = "找回密码")
    @PostMapping("/findpassword")
    public void findPassword(@RequestBody FindPswDto findPswDto) {

    }
}
```



# 接口实现

> 开发邮件工具类

````java
/**
 * 发送邮件
 *
 * @param email 收件邮箱号
 * @param code  验证码
 * @throws MessagingException
 */
public static void sendTestMail(String email, String code) throws MessagingException {

    // 创建Properties类，记录邮箱的属性
    Properties properties = new Properties();
    // SMTP发送邮件，必须进行身份验证
    properties.put("mail.smtp.auth", "true");
    // SMTP服务器
    properties.put("mail.smtp.host", "smtp.qq.com");
    //端口号，QQ邮箱端口587
    properties.put("mail.smtp.port", "587");
    // 发件人账户
    properties.put("mail.user", "2445645059@qq.com");
    // 此处填写16位STMP口令
    properties.put("mail.password", "mlyfwuyfkfooechc");
    // 构建授权信息，用于进行SMTP进行身份验证
    Authenticator authenticator = new Authenticator() {
        protected PasswordAuthentication getPasswordAuthentication() {
            // 用户名、密码
            String userName = properties.getProperty("mail.user");
            String password = properties.getProperty("mail.password");
            return new PasswordAuthentication(userName, password);
        }
    };
    // 使用环境属性和授权信息，创建邮件会话
    Session mailSession = Session.getInstance(properties, authenticator);
    // 创建邮件消息
    MimeMessage message = new MimeMessage(mailSession);
    // 设置发件人
    InternetAddress form = new InternetAddress(properties.getProperty("mail.user"));
    message.setFrom(form);
    // 设置收件人的邮箱
    InternetAddress to = new InternetAddress(email);
    message.setRecipient(MimeMessage.RecipientType.TO, to);
    // 设置邮件标题
    message.setSubject("CyanChau 邮件测试");
    // 设置邮件的内容体
    message.setContent("尊敬的用户:你好!\n注册验证码为:" + code + "(有效期为一分钟,请勿告知他人)", "text/html;charset=UTF-8");
    // 最后当然就是发送邮件啦
    Transport.send(message);
}
````

```java
/**
 *  生成验证码
 * @return
 */
public static String achieveCode() {  //由于数字 1 、 0 和字母 O 、l 有时分不清楚，所以，没有数字 1 、 0
    String[] beforeShuffle = new String[]{"2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F",
            "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a",
            "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v",
            "w", "x", "y", "z"};
    List<String> list = Arrays.asList(beforeShuffle);//将数组转换为集合
    Collections.shuffle(list);  //打乱集合顺序
    StringBuilder sb = new StringBuilder();
    for (String s : list) {
        sb.append(s); //将集合转化为字符串
    }
    return sb.substring(3, 8);
}
```

> 业务层

```java
public interface SendCodeService {

    /**
     * 向目标邮箱发送验证码
     * 
     * @param email 目标邮箱
     * @param code  我们发送的验证码
     */
    void sendEMail(String email, String code);
}

@Service
public class SendCodeServiceImpl implements SendCodeService {

    public final Long CODE_TTL = 120L;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void sendEMail(String email, String code) {
        // 1. 向用户发送验证码
        try {
            MailUtil.sendTestMail(email, code);
        } catch (MessagingException e) {
            log.info("邮件发送失败：{}", e.getMessage());
            BusinessException.cast("发送验证码失败，请稍后再试");
        }
        // 2. 将验证码缓存到redis，TTL设置为2分钟
        stringRedisTemplate.opsForValue().set(email, code, CODE_TTL, TimeUnit.SECONDS);
    }
}
```

 注意要事先在auth工程中导入redis的依赖 

```xml
<!--redis依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!--common-pool-->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

```java
public interface VerifyService {

    /**
     * 找回密码
     * 
     * @param findPswDto
     */
    void findPassword(FindPswDto findPswDto);
}
```

```java
@Service
public class VerifyServiceImpl implements VerifyService {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Resource
    private XcUserMapper xcUserMapper;

    public Boolean verifyCheckCode(String email, String checkcode) {
        // 1. 从redis中获取缓存的验证码
        String codeInRedis = stringRedisTemplate.opsForValue().get(email);
        // 2. 判断是否与用户输入的一致
        if (codeInRedis.equalsIgnoreCase(checkcode)) {
            stringRedisTemplate.delete(email);
            return true;
        }
        return false;
    }

    @Override
    public void findPassword(FindPswDto findPswDto) {
        String email = findPswDto.getEmail();
        String checkcode = findPswDto.getCheckcode();
        Boolean verifyCheckCode = verifyCheckCode(email, checkcode);
        if (!verifyCheckCode) {
            throw new RuntimeException("验证码输入错误");
        }
        String password = findPswDto.getPassword();
        String confirmpwd = findPswDto.getConfirmpwd();
        if (!password.equals(confirmpwd)) {
            throw new RuntimeException("两次输入的密码不一致");
        }
        LambdaQueryWrapper<XcUser> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(XcUser::getEmail, findPswDto.getEmail());
        XcUser user = xcUserMapper.selectOne(lambdaQueryWrapper);
        if (user == null) {
            throw new RuntimeException("用户不存在");
        }
        user.setPassword(new BCryptPasswordEncoder().encode(password));
        xcUserMapper.updateById(user);
    }
}
```

