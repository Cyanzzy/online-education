# 接入规范

## 接入流程

微信扫码登录基于OAuth2协议的授权码模式，

[接口文档](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html)

> 接入流程

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-163.png)第三方应用获取access_token令牌后即可请求微信获取用户的信息，成功获取到用户的信息表示用户在第三方应用认证成功。

## 请求获取授权码

第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login），则可以通过在 PC 端打开以下链接： https://open.weixin.qq.com/connect/qrconnect?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect 若提示“该链接无法访问”，请检查参数是否填写错误，如redirect_uri的域名与审核时填写的授权域名不一致或 scope 不为snsapi_login。

> 参数说明

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-164.png)

> 返回说明

用户允许授权后，将会重定向到redirect_uri的网址上，并且带上 code 和state参数

```json
redirect_uri?code=CODE&state=STATE
```

若用户禁止授权，则不会发生重定向。

登录一号店网站应用 https://test.yhd.com/wechat/login.do 打开后，一号店会生成 state 参数，跳转到 https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&redirect_uri=https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&response_type=code&scope=snsapi_login&state=3d6be0a4035d839573b04816624a415e#wechat_redirect 微信用户使用微信扫描二维码并且确认登录后，PC端会跳转到 https://test.yhd.com/wechat/callback.do?code=CODE&state=3d6be0a40sssssxxxxx6624a415e 为了满足网站更定制化的需求，我们还提供了第二种获取 code 的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过 JS 将code返回给网站。 JS微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。 

> 网站内嵌二维码微信登录 JS 实现办法：

步骤1：在页面中先引入如下 JS 文件（支持https）  

```js
http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js
```

步骤2：在需要使用微信登录的地方实例以下JS对象

```Js
 var obj = new WxLogin({
     self_redirect:true,
     id:"login_container", 
     appid: "", 
     scope: "", 
     redirect_uri: "",
      state: "",
     style: "",
     href: ""
 });
```

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-165.png)

## 通过 code 获取access_token

通过 code 获取access_token

```json
https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_codes
```

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-166.png)

> 返回说明

正确返回

```json
{ 
"access_token":"ACCESS_TOKEN", 
"expires_in":7200, 
"refresh_token":"REFRESH_TOKEN",
"openid":"OPENID", 
"scope":"SCOPE",
"unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"
}
```

 错误返回  

```json
{"errcode":40029,"errmsg":"invalid code"}
```

> 参数说明

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-167.png)

## 通过access_token调用接口

获取access_token后，进行接口调用，有以下前提：

> access_token有效且未超时；
>
> 微信用户已授权给第三方应用帐号相应接口作用域（scope）。  

对于接口作用域（scope），能调用的接口有以下：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-168.png)

其中snsapi_base属于基础接口，若应用已拥有其它 scope 权限，则默认拥有snsapi_base的权限。使用snsapi_base可以让移动端网页授权绕过跳转授权登录页请求用户授权的动作，直接跳转第三方网页带上授权临时票据（code），但会使得用户已授权作用域（scope）仅为snsapi_base，从而导致无法获取到需要用户授权才允许获得的数据和基础功能。 接口调用方法可查阅[《微信授权关系接口调用指南》](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html)

获取用户信息接口文档：https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html

> 接口地址

```json
http请求方式: GET
https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID
```

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-169.png)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-170.png)

```text
参数            说明
openid        普通用户的标识，对当前开发者帐号唯一
nickname        普通用户昵称
sex            普通用户性别，1为男性，2为女性
province        普通用户个人资料填写的省份
city            普通用户个人资料填写的城市
country        国家，如中国为CN
headimgurl        用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空
privilege        用户特权信息，json数组，如微信沃卡用户为（chinaunicom）
unionid          用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的 unionid 是唯一的。
```

# 准备开发环境

## 添加应用

1、注册微信开放平台

https://open.weixin.qq.com/

2、添加应用

进入网站应用，添加应用

3、添加应用需要指定一个外网域名作为微信回调域名

审核通过后，生成app密钥。

最终获取appID和AppSecret

## 内网穿透

我们的开发环境在局域网，微信回调指向一个公网域名。如何让微信回调请求至我们的开发计算机上呢？可以使用内网穿透技术

内网穿透简单来说就是将内网外网通过隧道打通,让内网的数据让外网可以获取。开启隧道之后，网穿透工具会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~~

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-171.png)

1、在内网穿透服务器上开通隧道，配置外网域名，配置穿透内网的端口即本地电脑上的端口。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-172.png)

配置认证服务端口，最终实现通过外网域名访问本地认证服务。

2、在本地电脑上安装内网穿透的工具，工具上配置内网穿透服务器隧道token。

市面上做内网穿透的商家很多，需要时可以查阅资料了解下。

# 接入微信登录

## 接入分析

> 接入流程

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/online-education-20230122-173.png)

1、需要定义接口接收微信下发的授权码。

2、收到授权码调用微信接口申请令牌。

3、申请到令牌调用微信获取用户信息

4、获取用户信息成功将其写入本项目用户中心数据库。

5、最后重定向到浏览器自动登录。

## 定义接口

参考接口规范中“请求获取授权码” 定义接收微信下发的授权码接口，

> 定义WechatLoginController类如下

```java
@Slf4j
@Controller
public class WeChatLoginController {

    @RequestMapping("/wxLogin")
    public String wechatLogin(String code, String state) {
        log.debug("微信扫码回调,code:{},state:{}", code, state);
        // 请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库
        XcUser xcUser = new XcUser();
        // 暂时硬编写，目的是调试环境
        xcUser.setUsername("t1");
        if (xcUser == null) {
            return "redirect:http://www.51xuecheng.cn/error.html";
        }
        String username = xcUser.getUsername();
        return "redirect:http://www.51xuecheng.cn/sign.html?username=" + username + "&authType=wx";

    }
    
}
```

> 定义微信认证Service

```java
@Service("wechatAuthService")
public class WechatAuthServiceImpl implements AuthService {

    @Resource
    private XcUserMapper xcUserMapper;

    @Override
    public XcUserExt execute(AuthParamsDto authParamsDto) {
        //账号
        String username = authParamsDto.getUsername();
        XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));
        if (user == null) {
            //返回空表示用户不存在
            throw new RuntimeException("账号不存在");
        }
        XcUserExt xcUserExt = new XcUserExt();
        BeanUtils.copyProperties(user, xcUserExt);
        return xcUserExt;

    }
}
```

## 接口环境测试

目的是测试接口调度的环境。

1、启动内网穿透工具

2、在/wxLogin接口中打断点

3、打开前端微信扫码页面

击微信图标打开二维码，用户扫码，确认授权

此时正常进入 /wxLogin 方法，最后跳转到http://www.51xuecheng.cn/sign.html?username=t1&authType=wx。

## 申请令牌

使用restTemplate请求微信，配置RestTemplate bean

在启动类配置restTemplate

```Java
@Bean
RestTemplate restTemplate() {
    RestTemplate restTemplate = new RestTemplate(new OkHttp3ClientHttpRequestFactory());

    return restTemplate;
}
```

定义与微信认证的service接口：

```java
public interface WechatAuthService {

    /**
     * 微信扫码认证
     *  1. 申请令牌
     *  2. 携带令牌查询用户信息
     *  3. 保存用户信息到数据库
     * @param code
     * @return
     */
    XcUser wechatAuth(String code);
}
```

> 携带授权码申请令牌

```java
/**
 * 携带授权码申请令牌
 * 响应示例
 * {
 * "access_token":"ACCESS_TOKEN",
 * "expires_in":7200,
 * "refresh_token":"REFRESH_TOKEN",
 * "openid":"OPENID",
 * "scope":"SCOPE",
 * "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"
 * }
 *
 * @param code
 * @return
 */
private Map<String, String> getAccessToken(String code) {

    // url模板
    String urlTemplate = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code";
    // 最终请求路径
    String url = String.format(urlTemplate, appid, secret, code);

    // 远程调用此url
    ResponseEntity<String> exchange = restTemplate.exchange(url, HttpMethod.POST, null, String.class);
    // 响应结果
    String result = exchange.getBody();
    // result数据转map
    Map<String, String> map = JSON.parseObject(result, Map.class);
    return map;
}
```

> 携带令牌获取用户信息

```java
/**
 * 携带令牌获取用户信息
 * <p>
 * {
 * "openid":"OPENID",
 * "nickname":"NICKNAME",
 * "sex":1,
 * "province":"PROVINCE",
 * "city":"CITY",
 * "country":"COUNTRY",
 * "headimgurl": "https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0",
 * "privilege":[
 * "PRIVILEGE1",
 * "PRIVILEGE2"
 * ],
 * "unionid": " o6_bmasdasdsad6_2sgVt7hMZOPfL"
 * }
 */
private Map<String, String> getUserinfo(String accessToken, String openid) {

    String urlTemplate = "https://api.weixin.qq.com/sns/userinfo?access_token=%s&openid=%s";
    String wxUrl = String.format(urlTemplate, accessToken, openid);

    ResponseEntity<String> exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, null, String.class);

    //防止乱码进行转码
    String result = new String(exchange.getBody().getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);

    Map<String, String> map = JSON.parseObject(result, Map.class);

    return map;
}
```

> 保存用户信息

```java
/**
 * 保存用户信息
 *
 * @param userInfoMap
 * @return
 */
@Transactional
public XcUser addWechatUser(Map<String, String> userInfoMap) {
    String unionid = userInfoMap.get("unionid");
    String nickname = userInfoMap.get("nickname");
    // 根据unionid查询用户信息
    XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getWxUnionid, unionid));
    if (xcUser != null) {
        return xcUser;
    }
    // 新增记录
    xcUser = new XcUser();

    String userId = UUID.randomUUID().toString();
    xcUser.setId(userId);
    xcUser.setUsername(unionid);
    xcUser.setPassword(unionid);
    xcUser.setWxUnionid(unionid);
    xcUser.setNickname(nickname);
    xcUser.setName(nickname);
    xcUser.setUtype("101001"); // 学生类型
    xcUser.setStatus("1"); // 用户状态
    xcUser.setCreateTime(LocalDateTime.now());
    xcUserMapper.insert(xcUser);

    // 用户角色关系表
    XcUserRole xcUserRole = new XcUserRole();

    xcUserRole.setId(UUID.randomUUID().toString());
    xcUserRole.setUserId(userId);
    xcUserRole.setRoleId("17"); // 学生角色
    xcUserRole.setCreateTime(LocalDateTime.now());
    xcUserRoleMapper.insert(xcUserRole);

    return xcUser;
}
```

1、在保存用户信息处打断点

2、进入http://www.51xuecheng.cn/wxsign.html

3、手机扫码授权

4、自动跳转到登录页面，提交认证成功。